head	1.34;
access;
symbols;
locks
	kempa:1.34; strict;
comment	@# @;


1.34
date	2012.06.20.13.03.17;	author kempa;	state Exp;
branches;
next	1.33;

1.33
date	2012.06.20.12.02.18;	author kempa;	state Exp;
branches;
next	1.32;

1.32
date	2012.06.20.11.53.27;	author kempa;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.19.16.54.14;	author kempa;	state Exp;
branches;
next	1.30;

1.30
date	2012.06.19.12.17.29;	author kempa;	state Exp;
branches;
next	1.29;

1.29
date	2012.06.19.07.10.46;	author kempa;	state Exp;
branches;
next	1.28;

1.28
date	2012.06.19.05.46.00;	author kempa;	state Exp;
branches;
next	1.27;

1.27
date	2012.06.19.03.17.15;	author kempa;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.18.21.05.43;	author kempa;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.18.20.01.35;	author kempa;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.18.19.19.46;	author kempa;	state Exp;
branches;
next	1.23;

1.23
date	2012.06.18.17.03.47;	author kempa;	state Exp;
branches;
next	1.22;

1.22
date	2012.06.18.13.34.20;	author kempa;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.18.11.54.59;	author kempa;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.18.10.25.39;	author kempa;	state Exp;
branches;
next	1.19;

1.19
date	2012.06.18.08.38.42;	author kempa;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.18.07.59.11;	author kempa;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.17.12.57.42;	author kempa;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.17.12.51.48;	author kempa;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.17.12.08.55;	author kempa;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.17.06.09.44;	author kempa;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.17.02.54.26;	author kempa;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.16.17.37.42;	author kempa;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.16.16.49.45;	author kempa;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.15.12.36.24;	author kempa;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.15.09.34.27;	author kempa;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.15.07.53.43;	author kempa;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.15.07.38.01;	author kempa;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.14.19.15.26;	author kempa;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.14.10.17.09;	author kempa;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.13.07.46.52;	author kempa;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.11.17.44.45;	author kempa;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.11.17.36.51;	author kempa;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.11.15.06.41;	author kempa;	state Exp;
branches;
next	;


desc
@@


1.34
log
@*** empty log message ***
@
text
@import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import java.util.Vector;

/** This class is used to contain the semantic information about the class strucure of the program*/ 
class ClassTable {
    // For error reporting
    private int semantErrors;
    private PrintStream errorStream;

    // Points to the explicitly constructed list of basic class nodes. Note that this is not attached to the AST given by the parser
    private Classes basicClasses;

    // References the user defined classes of the program as given in the AST by the parser
    private Classes userClasses;

    // Data structure to represent the inheritance relationship of the classes of the program
    private InheritanceGraph ig;

    /** Creates data structures representing basic Cool classes (Object,
     * IO, Int, Bool, String).
     * */
    private void installBasicClasses() {
		AbstractSymbol filename 
		    = AbstractTable.stringtable.addString("<basic class>");
		
		// The following demonstrates how to create dummy parse trees to
		// refer to basic Cool classes.  There's no need for method
		// bodies -- these are already built into the runtime system.
	
		// The Object class has no parent class. Its methods are
		//        cool_abort() : Object    aborts the program
		//        type_name() : Str        returns a string representation 
		//                                 of class name
		//        copy() : SELF_TYPE       returns a copy of the object
	
		class_c Object_class = 
		    new class_c(0, 
			       TreeConstants.Object_, 
			       TreeConstants.No_class,
			       new Features(0)
				   .appendElement(new method(0, 
						      TreeConstants.cool_abort, 
						      new Formals(0), 
						      TreeConstants.Object_, 
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.type_name,
						      new Formals(0),
						      TreeConstants.Str,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.copy,
						      new Formals(0),
						      TreeConstants.SELF_TYPE,
						      new no_expr(0))),
			       filename);
		
		// The IO class inherits from Object. Its methods are
		//        out_string(Str) : SELF_TYPE  writes a string to the output
		//        out_int(Int) : SELF_TYPE      "    an int    "  "     "
		//        in_string() : Str            reads a string from the input
		//        in_int() : Int                "   an int     "  "     "
	
		class_c IO_class = 
		    new class_c(0,
			       TreeConstants.IO,
			       TreeConstants.Object_,
			       new Features(0)
				   .appendElement(new method(0,
						      TreeConstants.out_string,
						      new Formals(0)
							  .appendElement(new formalc(0,
									     TreeConstants.arg,
									     TreeConstants.Str)),
						      TreeConstants.SELF_TYPE,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.out_int,
						      new Formals(0)
							  .appendElement(new formalc(0,
									     TreeConstants.arg,
									     TreeConstants.Int)),
						      TreeConstants.SELF_TYPE,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.in_string,
						      new Formals(0),
						      TreeConstants.Str,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.in_int,
						      new Formals(0),
						      TreeConstants.Int,
						      new no_expr(0))),
			       filename);
	
		// The Int class has no methods and only a single attribute, the
		// "val" for the integer.
	
		class_c Int_class = 
		    new class_c(0,
			       TreeConstants.Int,
			       TreeConstants.Object_,
			       new Features(0)
				   .appendElement(new attr(0,
						    TreeConstants.val,
						    TreeConstants.prim_slot,
						    new no_expr(0))),
			       filename);
	
		// Bool also has only the "val" slot.
		class_c Bool_class = 
		    new class_c(0,
			       TreeConstants.Bool,
			       TreeConstants.Object_,
			       new Features(0)
				   .appendElement(new attr(0,
						    TreeConstants.val,
						    TreeConstants.prim_slot,
						    new no_expr(0))),
			       filename);
	
		// The class Str has a number of slots and operations:
		//       val                              the length of the string
		//       str_field                        the string itself
		//       length() : Int                   returns length of the string
		//       concat(arg: Str) : Str           performs string concatenation
		//       substr(arg: Int, arg2: Int): Str substring selection
	
		class_c Str_class =
		    new class_c(0,
			       TreeConstants.Str,
			       TreeConstants.Object_,
			       new Features(0)
				   .appendElement(new attr(0,
						    TreeConstants.val,
						    TreeConstants.Int,
						    new no_expr(0)))
				   .appendElement(new attr(0,
						    TreeConstants.str_field,
						    TreeConstants.prim_slot,
						    new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.length,
						      new Formals(0),
						      TreeConstants.Int,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.concat,
						      new Formals(0)
							  .appendElement(new formalc(0,
									     TreeConstants.arg, 
									     TreeConstants.Str)),
						      TreeConstants.Str,
						      new no_expr(0)))
				   .appendElement(new method(0,
						      TreeConstants.substr,
						      new Formals(0)
							  .appendElement(new formalc(0,
									     TreeConstants.arg,
									     TreeConstants.Int))
							  .appendElement(new formalc(0,
									     TreeConstants.arg2,
									     TreeConstants.Int)),
						      TreeConstants.Str,
						      new no_expr(0))),
			       filename);
	
	    basicClasses = new Classes(0);
	    basicClasses.appendElement(Object_class);
	    basicClasses.appendElement(IO_class);
	    basicClasses.appendElement(Int_class);
	    basicClasses.appendElement(Bool_class);
	    basicClasses.appendElement(Str_class);
    }

    /** Prints line number and file name of the given class.
     *
     * Also increments semantic error count.
     *
     * @@param c the class
     * @@return a print stream to which the rest of the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError(class_c c) {
	    return semantError(c.getFilename(), c);
    }

    /** Prints the file name and the line number of the given tree node.
     *
     * Also increments semantic error count.
     *
     * @@param filename the file name
     * @@param t the tree node
     * @@return a print stream to which the rest of the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError(AbstractSymbol filename, TreeNode t) {
    	errorStream.print(filename + ":" + t.getLineNumber() + ": ");
    	return semantError();
    }

    /** Increments semantic error count and returns the print stream for
     * error messages.
     *
     * @@return a print stream to which the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError() {
	    semantErrors++;
    	return errorStream;
    }

    /** Returns true if there are any static semantic errors. */
    public boolean errors() {
	    return semantErrors != 0;
    }


    // Policy on error: Return immediately
    public ClassTable(Classes cls)  throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
        semantErrors = 0;
    	errorStream = System.err;
        installBasicClasses();
    
        // Check for duplicate definitions of classes
        Classes lst = new Classes(cls.lineNumber);
        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();) {
            class_c c = e.nextElement();
            if (c.getName().equals(TreeConstants.SELF_TYPE)) {
                semantError(c).println("Redefinition of basic class " + c.getName() + ".");
                return;
            }
            else if (isDefined(basicClasses, c.getName())) {
                semantError(c).println("Redefinition of basic class " + c.getName() + ".");
                return;
            }
            else if (isDefined(lst, c.getName())) {
                semantError(c).println("Class " + c.getName() + " was previously defined.");
                return;
            }
            else
                lst.addElement(c);
        }

        // If everything is ok, set userClasses.
        userClasses = cls;
        // The below can be done only once it is ensured that there is no redefinition of user defined classes

        // is class Main defined?
        if (!isDefined(userClasses, TreeConstants.Main)) {
            semantError().println("Class Main is not defined.");
            return;
        }

        // inheriting from a valid type.
        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();) {
            class_c c = e.nextElement();
            if (c.getParent().equals(TreeConstants.SELF_TYPE) || c.getParent().equals(TreeConstants.Bool) || c.getParent().equals(TreeConstants.Str)) {
                semantError(c).println("Class " + c.getName() + " cannot inherit class " + c.getParent() + ".");
                return;
            }
            if (!isDefined(c.getParent())) {
                semantError(c).println("Class " + c.getName() + " inherits from an undefined class " + c.getParent() + ".");
                return;
            }
        }

        // if all is well construct a inheritance graph and chek for a cycle
        ig = new InheritanceGraph(userClasses, basicClasses);
        if (ig.hasCycle()) 
            for (AbstractSymbol s : ig.cycle())
                semantError(get_class_c(s)).println("Class " + s + ", or an ancestor of " + s + ", is involved in an inheritance cycle.");
    }

    /**
     * Gets the class_c object with the specified name in the program. 
     * A lookup is done through the basic classes and user defined classes.
     * Note : Always use this in after a check with isDefinedClass() to avoid a possible null derefernce
     *
     */
    public class_c get_class_c(AbstractSymbol type) throws PossibleNullDereferenceException {
        try {
            return get_class_c(userClasses, type);
        } catch(PossibleNullDereferenceException ex) {
            return get_class_c(basicClasses, type);
        }
    }

    /**
     * Gets the class_c object with the specified name in specified class list(the user class list or the basic class list. 
     */
    private class_c get_class_c(Classes classes, AbstractSymbol name) throws PossibleNullDereferenceException {
        for (Enumeration<class_c> e = classes.getElements(); e.hasMoreElements();) {
            class_c c = e.nextElement();
            if (c.getName().equals(name)) 
                    return c;
        }
        throw new PossibleNullDereferenceException("Internal Error : No class called " + name + ". Use a isDefined(name) before handed.");
    }

    /**
     * Determines if the specified type is a valid defined type.
     * A lookup is done in the user and basic class list
     */
    public boolean isDefined(AbstractSymbol type) throws UnresolvableSelfTypeException {
        if (!isDefined(userClasses, type)) // a in class invocation always contains resolved types
            return isDefined(basicClasses, type);
        return true;
    }
    /**
     * Determines if the specfied type is a valid defined type in the specified class list(user class list or basic class list.
     */
    private boolean isDefined(Classes classes, AbstractSymbol type) throws UnresolvableSelfTypeException {
        if (type.equals(TreeConstants.SELF_TYPE))
            throw new UnresolvableSelfTypeException();
        for (Enumeration e = classes.getElements(); e.hasMoreElements(); )
	        if (((class_c)e.nextElement()).getName().equals(type))
                return true;
        return false;
    }

    /**
     * Gets a list of supertypes of the specified symbol in a given context.
     * Note: The specified type is also its supertype
     *
     * @@param type The type whose supertypes is sough
     * @@return A list of supertypes
     */
    public Vector<AbstractSymbol> supertypes(AbstractSymbol type) throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
        return ig.supertypes(type);
	}

    /**
     * Determines the least upper bound of two specified types
     *
     * @@param A type
     * @@param A type
     * @@return The least upper bound or the least common ancestor
     */
    public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2)  throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
        return ig.lub(t1, t2); 
    }


    /**
     * Data structure to represent the inheritance relationship of the classes of the program.
     * Provides two important facilities
     *  1. Determines if the inheritance relationship is cyclic
     *  2. Determines the supertypes of a given type
     */
	private class InheritanceGraph 	{
        // To represent the inheritance relationship
	    private SymbolDigraph<AbstractSymbol> sg;

        // Helps find cycles
	    private DirectedCycleDFS cycleFinder;
	    

	    private InheritanceGraph(Classes userClasses, Classes basicClasses) {
	        sg = new SymbolDigraph<AbstractSymbol>(userClasses.getLength() + basicClasses.getLength()); 

            // Add the inheritance relationship of basic types with root type 'Object'
	        for (Enumeration<class_c> e = basicClasses.getElements(); e.hasMoreElements();)  {
	            class_c c = e.nextElement();
                try {
                    if (!c.getName().equals(TreeConstants.Object_))
                        sg.addEdge(TreeConstants.Object_, c.getName());
                }
                catch(Exception ex) {
                    // Relationships of basic type with objects do not consist of self loops, parallel edges or invalid edges
                    continue;
	            }
            }

            // Add the inheritance relationship of specified in the program
	        for (Enumeration<class_c> e = userClasses.getElements(); e.hasMoreElements();)  {
	            class_c c = e.nextElement();
                try {
	                sg.addEdge(c.getParent(), c.getName()); 
                 }
                catch(SelfLoopExistsException ex) {
    	            semantError(c).println("Class " + c.getParent() + ", or an ancestor of " + c.getName() + ", is involved in an inheritance cycle.");
	            }
	            catch(InvalidEdgeException ex) {
	                System.out.println("Internal Error : InheritanceGraph : Error constructing inheritance tree - \"" + ex + "\"");
	                ex.printStackTrace();
	                System.exit(2);
	            }
	            catch(ParallelEdgeExistsException ex) {
                    continue;
                    // This cannot occur as checks for redefined classes have been successful
                }
	        }
	        cycleFinder = new DirectedCycleDFS(sg.G());
	    }
	

	    private boolean hasCycle() {
	        return cycleFinder.hasCycle();
	    }
	   

	    private Iterable<AbstractSymbol> cycle()  throws PossibleNullDereferenceException {
	        if (hasCycle()) {
	            Vector<AbstractSymbol> lst = new Vector<AbstractSymbol>();
	            for (Iterator<Integer> i = cycleFinder.cycle().iterator(); i.hasNext();) {
	                int v = i.next();
	                if (i.hasNext())  // don't want to add the last repeated class of the cycle
	                    lst.add(get_class_c(sg.name(v)).name);
	            }
	            return lst;
	        }
            throw new PossibleNullDereferenceException("Internal Error: There is no cycle in the inheritance graph. Use a hasCycle()");
	   }
	 
       /**
        * Returns ancestors in the increasing order of inheritance.
        *
        */
        private Vector<AbstractSymbol> supertypes(AbstractSymbol type) throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
            if (type.equals(TreeConstants.SELF_TYPE))
                throw new UnresolvableSelfTypeException();

            Vector<AbstractSymbol> lst = new Vector<AbstractSymbol>();
            int t = sg.index(type);
            for (int v = 0; v < sg.G().V(); v++) {
                PathsDFS paths = new PathsDFS(sg.G(), v);
                if (paths.hasPathTo(t)) {
                    for (Integer w : paths.pathTo(t))
                            lst.add(get_class_c(sg.name(w)).name);
                    return lst;
                }
            }
            throw new PossibleNullDereferenceException("Internal Error : There must be atleast one supertype of any type - itself");
    	}
  
       /**
        * Determines the least upper bound of two specified types.
        *
        * The inheritance relationship in cool is a tree(due to single inheritance). Thus consider the paths from the root object to the specified types. As supertypes(type) returns the supertypes in the order of the decreasing types, the lub is the type at which the path bisects
        *
        */
        private AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2)  throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
           if (t1.equals(TreeConstants.No_type))
               return t2;
           else if (t2.equals(TreeConstants.No_type))
               return t1;

           AbstractSymbol lub = TreeConstants.Object_;
           for(Enumeration e1 = supertypes(t1).elements(), e2 = supertypes(t2).elements(); e1.hasMoreElements() && e2.hasMoreElements();) {
              AbstractSymbol a1 = (AbstractSymbol)e1.nextElement();
              AbstractSymbol a2 = (AbstractSymbol)e2.nextElement();
              if ( a1 != a2) {
                  return lub;
              }
              lub = a1; // or a2
            }
           return lub;
        }
	}// class InheritanceGraph
}// class ClassTable


@


1.33
log
@Cleaned Design
@
text
@a227 1
    // To do : Need to check error() afterwards
@


1.32
log
@Cleaned design
@
text
@a284 10
     * Resolves a type name.
     * A type name is resolved if it is guareented not to be a context dependent placeholder, the SELF_TYPE.
     */
    public AbstractSymbol getResolvedType(AbstractSymbol type, class_c container) {
        if (type.equals(TreeConstants.SELF_TYPE))
            return container.getName();
        return type;
    }

    /**
a468 3



a471 5
class UnresolvableSelfTypeException extends Exception {
    UnresolvableSelfTypeException() {
            super("Internal Error: Cannot resolve SELF_TYPE without an enclosing class");
    }
}
@


1.31
log
@*** empty log message ***
@
text
@d300 1
a300 9
    public class_c get_class_c(AbstractSymbol type, class_c container) throws PossibleNullDereferenceException {
        try {
            return get_class_c(userClasses, getResolvedType(type, container));
        } catch(PossibleNullDereferenceException ex) {
            return get_class_c(basicClasses, getResolvedType(type, container));
        }
    }

    private class_c get_class_c(AbstractSymbol type) throws PossibleNullDereferenceException {
d324 1
a324 7
    public boolean isDefined(AbstractSymbol type, class_c container) throws UnresolvableSelfTypeException {
        if (!isDefined(userClasses, getResolvedType(type, container)))
            return isDefined(basicClasses, getResolvedType(type, container));
        return true;
    }

    private boolean isDefined(AbstractSymbol type) throws UnresolvableSelfTypeException {
d348 2
a349 2
    public Vector<AbstractSymbol> supertypes(AbstractSymbol type, class_c container) throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
        return ig.supertypes(getResolvedType(type, container));
d359 2
a360 2
    public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2, class_c container)  throws PossibleNullDereferenceException, UnresolvableSelfTypeException {
        return ig.lub(getResolvedType(t1, container), getResolvedType(t2, container)); 
@


1.30
log
@*** empty log message ***
@
text
@d180 47
a226 1
	
d229 1
a229 1
    public ClassTable(Classes cls)  throws PossibleNullDereferenceException {
d238 5
a242 1
            if (isDefined(basicClasses, c.getName()) || c.getName().equals(TreeConstants.SELF_TYPE)) {
d284 9
d300 1
a300 1
    public class_c get_class_c(AbstractSymbol name) throws PossibleNullDereferenceException {
d302 1
a302 1
            return get_class_c(userClasses, name);
d304 9
a312 1
            return get_class_c(basicClasses, name);
d332 8
a339 2
    public boolean isDefined(AbstractSymbol type) {
        if (!isDefined(userClasses, type))
a342 1

a344 1
     * Note : The type, SELF_TYPE, is determined to be a valid type in both the lists though it does not an actual presence in the lists as it is representative of the type of the enclosing class.
d346 1
a346 1
    private boolean isDefined(Classes classes, AbstractSymbol type) {
d348 1
a348 1
            return true;
a354 46

    /** Prints line number and file name of the given class.
     *
     * Also increments semantic error count.
     *
     * @@param c the class
     * @@return a print stream to which the rest of the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError(class_c c) {
	    return semantError(c.getFilename(), c);
    }

    /** Prints the file name and the line number of the given tree node.
     *
     * Also increments semantic error count.
     *
     * @@param filename the file name
     * @@param t the tree node
     * @@return a print stream to which the rest of the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError(AbstractSymbol filename, TreeNode t) {
    	errorStream.print(filename + ":" + t.getLineNumber() + ": ");
    	return semantError();
    }

    /** Increments semantic error count and returns the print stream for
     * error messages.
     *
     * @@return a print stream to which the error message is
     * to be printed.
     *
     * */
    public PrintStream semantError() {
	    semantErrors++;
    	return errorStream;
    }

    /** Returns true if there are any static semantic errors. */
    public boolean errors() {
	    return semantErrors != 0;
    }

a359 1
     * @@param c The class in which 'type' appears. This is required in case the specified type is SELF_TYPE.
d362 2
a363 3
    public Vector<AbstractSymbol> supertypes(AbstractSymbol type, class_c c) throws PossibleNullDereferenceException {
        // To do : Understand this
        return ig.supertypes(type, c);
d373 2
a374 2
    public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2, class_c c)  throws PossibleNullDereferenceException {
        return ig.lub(t1, t2, c);
d377 1
d384 1
a384 1
	class InheritanceGraph 	{
d392 1
a392 1
	    public InheritanceGraph(Classes userClasses, Classes basicClasses) {
d431 1
a431 1
	    public boolean hasCycle() {
d436 1
a436 1
	    public Iterable<AbstractSymbol> cycle()  throws PossibleNullDereferenceException {
d453 3
a455 6
        public Vector<AbstractSymbol> supertypes(AbstractSymbol type, class_c c) throws PossibleNullDereferenceException {
        if (type.equals(TreeConstants.SELF_TYPE)) {
            Vector<AbstractSymbol> supertypes = ig.supertypes(c.name, c);
            supertypes.add(TreeConstants.SELF_TYPE);
            return supertypes;
        }
d476 1
a476 1
        public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2, class_c c)  throws PossibleNullDereferenceException {
d483 1
a483 1
           for(Enumeration e1 = supertypes(t1, c).elements(), e2 = supertypes(t2, c).elements(); e1.hasMoreElements() && e2.hasMoreElements();) {
d493 3
d498 6
@


1.29
log
@*** empty log message ***
@
text
@d262 1
a262 1
     * Tells if the specified type is a valid defined type.
d271 4
@


1.28
log
@All tests pass
@
text
@d236 3
a238 1
     * Gets the class_c object with the specified name from the classes lists, userClasses and basicClasses.
a239 1
     * Returns null if no such class exists
d242 5
a246 5
        if (!isDefined(name))
            throw new PossibleNullDereferenceException("Internal Error: get_class_c : No class called " + name + ". Use a isDefined(name).");

        class_c c = get_class_c(userClasses, name);
        return ((c == null) ? get_class_c(basicClasses, name) : c);
d249 4
a252 1
    private class_c get_class_c(Classes classes, AbstractSymbol name) {
d258 1
a258 1
        return null;
d262 2
a263 2
     * Tells if the specified type is a valid defined type
     * Note : SELF_TYPE is not a type and hence isDefined(...) doesn't answer for it.
@


1.27
log
@*** empty log message ***
@
text
@d332 1
a332 6
        if (type.equals(TreeConstants.SELF_TYPE)) {
            Vector<AbstractSymbol> supertypes = ig.supertypes(c.name);
            supertypes.add(TreeConstants.SELF_TYPE);
            return supertypes;
        }
        return ig.supertypes(type);
d342 2
a343 2
    public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2)  throws PossibleNullDereferenceException {
        return ig.lub(t1, t2);
d421 7
a427 1
        public Vector<AbstractSymbol> supertypes(AbstractSymbol type) throws PossibleNullDereferenceException {
d438 1
a438 1
            return null;
d447 1
a447 1
        public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2)  throws PossibleNullDereferenceException {
d454 1
a454 1
           for(Enumeration e1 = supertypes(t1).elements(), e2 = supertypes(t2).elements(); e1.hasMoreElements() && e2.hasMoreElements();) {
@


1.26
log
@*** empty log message ***
@
text
@d456 1
a456 1
              if ( a1 != a2)
d458 1
@


1.25
log
@*** empty log message ***
@
text
@d243 1
@


1.24
log
@*** empty log message ***
@
text
@d217 2
a218 2
            if (c.getParent().equals(TreeConstants.SELF_TYPE)) {
                semantError(c).println("Class " + c.getName() + " cannot inherit class SELF_TYPE.");
d267 2
d330 1
d332 3
a334 1
            return ig.supertypes(c.name);
@


1.23
log
@*** empty log message ***
@
text
@d441 1
a441 1
           if (t1 == null)
d443 1
a443 1
           else if (t2 == null)
@


1.22
log
@*** empty log message ***
@
text
@d183 1
a183 1
    public ClassTable(Classes cls) {
d240 3
a242 5
    public class_c get_class_c(AbstractSymbol name) {
        if (!isDefined(name)) {
            System.out.println("Internal error: get_class_c : No class called " + name + ". Use a isDefined(name).");
            System.exit(2);
        }
d327 1
a327 1
    public Vector<AbstractSymbol> supertypes(AbstractSymbol type, class_c c){
d341 1
a341 1
    public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2) {
d403 1
a403 1
	    public Iterable<AbstractSymbol> cycle() {
d413 1
a413 3
            System.out.println("Internal Error: There is no cycle in the inheritance graph. Use a hasCycle()");
            System.exit(2);
            return null;
d420 1
a420 1
        public Vector<AbstractSymbol> supertypes(AbstractSymbol type){
d440 1
a440 1
        public AbstractSymbol lub(AbstractSymbol t1, AbstractSymbol t2) {
@


1.21
log
@*** empty log message ***
@
text
@d421 1
a421 1
        * Returns ancestors in the increasing order of inheritance. 
d437 7
a443 1
   
d456 1
a456 1
              lub = a1;
a462 2

// To : A better method of finding instead of a linear search. Need to change the way a collection is stored. Right now it is stored as a list(A vector)
@


1.20
log
@*** empty log message ***
@
text
@d181 2
a182 7
    // Does the following
    //  1. Installs basic classes
    //  2. Checks user classes for
    //      1. Duplicate definition
    //      2. Main class definition
    //      3. Inheritances from undefined classes
    //      4. Cyclic inheritances by constructing an inheritance graph
a187 1
        // Ponder : A better method for finding duplicates
a189 1
        boolean redefined = false;
d192 1
a192 1
            if (isDefined(basicClasses, c.getName())) {
d194 1
a194 1
                redefined = true;
d198 1
a198 1
                redefined = true;
d204 4
a207 6
        // If everything is ok, set userClasses
        if (redefined)
            return;
        else
            userClasses = cls;
    
d209 1
a209 1
        if (!isDefined(userClasses, TreeConstants.Main))
d211 2
d214 1
a214 1
        // inheriting from an undefined class
d223 1
a223 1
            return;
a226 5
        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();) {
            class_c c = e.nextElement();
            if (c.name.equals(TreeConstants.SELF_TYPE))
                 semantError(c).println("Redefinition of basic class SELF_TYPE.");
        }
d236 1
a236 2
     * Gets the class_c object with the specified name from the lists
     * userClasses and basicClasses.
d241 4
d260 1
d286 1
a286 1
	return semantError(c.getFilename(), c);
d300 2
a301 2
	errorStream.print(filename + ":" + t.getLineNumber() + ": ");
	return semantError();
d312 2
a313 2
	semantErrors++;
	return errorStream;
d318 1
a318 1
	return semantErrors != 0;
d321 8
a328 1

d336 7
d347 6
d354 1
d356 2
d360 1
d364 1
a364 1
            // Add all the basic classes first
d372 1
a372 1
                    // I know that there will be no exceptions while adding edges related to basic classes
d377 1
a377 1
            // add the user classes next
d379 1
a379 1
	                class_c c = e.nextElement();
d384 1
a384 1
	            semantError(c).println("Class " + c.getParent() + ", or an ancestor of " + c.getName() + ", is involved in an inheritance cycle.");
d387 1
a387 1
	                System.out.println("Internal Error : Error constructing inheritance tree - \"" + ex + "\"");
d389 1
a389 1
	                System.exit(1);
d391 4
a394 1
	            catch(ParallelEdgeExistsException ex) {}
d399 1
d415 3
a417 1
	        return null;
d456 3
@


1.19
log
@*** empty log message ***
@
text
@d8 1
a8 3
/** This class may be used to contain the semantic information such as
 * the inheritance graph. 
 */ 
d10 1
d13 2
d16 2
d19 2
d27 76
a102 2
	AbstractSymbol filename 
	    = AbstractTable.stringtable.addString("<basic class>");
d104 75
a178 149
	// The following demonstrates how to create dummy parse trees to
	// refer to basic Cool classes.  There's no need for method
	// bodies -- these are already built into the runtime system.

	// The Object class has no parent class. Its methods are
	//        cool_abort() : Object    aborts the program
	//        type_name() : Str        returns a string representation 
	//                                 of class name
	//        copy() : SELF_TYPE       returns a copy of the object

	class_c Object_class = 
	    new class_c(0, 
		       TreeConstants.Object_, 
		       TreeConstants.No_class,
		       new Features(0)
			   .appendElement(new method(0, 
					      TreeConstants.cool_abort, 
					      new Formals(0), 
					      TreeConstants.Object_, 
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.type_name,
					      new Formals(0),
					      TreeConstants.Str,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.copy,
					      new Formals(0),
					      TreeConstants.SELF_TYPE,
					      new no_expr(0))),
		       filename);
	
	// The IO class inherits from Object. Its methods are
	//        out_string(Str) : SELF_TYPE  writes a string to the output
	//        out_int(Int) : SELF_TYPE      "    an int    "  "     "
	//        in_string() : Str            reads a string from the input
	//        in_int() : Int                "   an int     "  "     "

	class_c IO_class = 
	    new class_c(0,
		       TreeConstants.IO,
		       TreeConstants.Object_,
		       new Features(0)
			   .appendElement(new method(0,
					      TreeConstants.out_string,
					      new Formals(0)
						  .appendElement(new formalc(0,
								     TreeConstants.arg,
								     TreeConstants.Str)),
					      TreeConstants.SELF_TYPE,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.out_int,
					      new Formals(0)
						  .appendElement(new formalc(0,
								     TreeConstants.arg,
								     TreeConstants.Int)),
					      TreeConstants.SELF_TYPE,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.in_string,
					      new Formals(0),
					      TreeConstants.Str,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.in_int,
					      new Formals(0),
					      TreeConstants.Int,
					      new no_expr(0))),
		       filename);

	// The Int class has no methods and only a single attribute, the
	// "val" for the integer.

	class_c Int_class = 
	    new class_c(0,
		       TreeConstants.Int,
		       TreeConstants.Object_,
		       new Features(0)
			   .appendElement(new attr(0,
					    TreeConstants.val,
					    TreeConstants.prim_slot,
					    new no_expr(0))),
		       filename);

	// Bool also has only the "val" slot.
	class_c Bool_class = 
	    new class_c(0,
		       TreeConstants.Bool,
		       TreeConstants.Object_,
		       new Features(0)
			   .appendElement(new attr(0,
					    TreeConstants.val,
					    TreeConstants.prim_slot,
					    new no_expr(0))),
		       filename);

	// The class Str has a number of slots and operations:
	//       val                              the length of the string
	//       str_field                        the string itself
	//       length() : Int                   returns length of the string
	//       concat(arg: Str) : Str           performs string concatenation
	//       substr(arg: Int, arg2: Int): Str substring selection

	class_c Str_class =
	    new class_c(0,
		       TreeConstants.Str,
		       TreeConstants.Object_,
		       new Features(0)
			   .appendElement(new attr(0,
					    TreeConstants.val,
					    TreeConstants.Int,
					    new no_expr(0)))
			   .appendElement(new attr(0,
					    TreeConstants.str_field,
					    TreeConstants.prim_slot,
					    new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.length,
					      new Formals(0),
					      TreeConstants.Int,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.concat,
					      new Formals(0)
						  .appendElement(new formalc(0,
								     TreeConstants.arg, 
								     TreeConstants.Str)),
					      TreeConstants.Str,
					      new no_expr(0)))
			   .appendElement(new method(0,
					      TreeConstants.substr,
					      new Formals(0)
						  .appendElement(new formalc(0,
								     TreeConstants.arg,
								     TreeConstants.Int))
						  .appendElement(new formalc(0,
								     TreeConstants.arg2,
								     TreeConstants.Int)),
					      TreeConstants.Str,
					      new no_expr(0))),
		       filename);

    basicClasses = new Classes(0);
    basicClasses.appendElement(Object_class);
    basicClasses.appendElement(IO_class);
    basicClasses.appendElement(Int_class);
    basicClasses.appendElement(Bool_class);
    basicClasses.appendElement(Str_class);
a191 1
        userClasses = new Classes(cls.lineNumber);
d193 1
d195 2
a196 2
        // If everythig ok, set userClasses
        boolean redefinition = false;
d201 1
a201 1
                redefinition = true;
d203 1
a203 1
            else if (isDefined(userClasses, c.getName())) {
d205 1
a205 1
                redefinition = true;
d208 1
a208 1
                userClasses.addElement(c);
d210 3
a212 1
        if (redefinition)
d214 2
d217 1
a217 1
        // is class Main defined
d224 5
a228 1
            if (!isDefined(userClasses, c.getParent()) && !isDefined(basicClasses, c.getParent())) {
d233 1
a270 2
        if (type.equals(TreeConstants.SELF_TYPE))
            return true;
@


1.18
log
@*** empty log message ***
@
text
@d194 1
a194 1
            if (basicClasses.isDefined(c.getName())) {
d198 1
a198 1
            else if (userClasses.isDefined(c.getName())) {
d209 1
a209 1
        if (!userClasses.isDefined(TreeConstants.Main))
d215 1
a215 1
            if (!userClasses.isDefined(c.getParent()) && !basicClasses.isDefined(c.getParent())) {
d240 11
a250 2
        class_c c = userClasses.get_class_c(name);
        return ((c == null) ? basicClasses.get_class_c(name) : c);
d256 1
a256 1
    public boolean defined(AbstractSymbol type) {
d259 2
a260 2
        if (!userClasses.isDefined(type))
            return basicClasses.isDefined(type);
d262 7
@


1.17
log
@*** empty log message ***
@
text
@d194 2
a195 3
            String className = c.getName().toString();
            if (basicClasses.defined(c.getName())) {
                semantError(c).println("Redefinition of basic class " + className + ".");
d198 2
a199 2
            else if (userClasses.defined(c.getName())) {
                semantError(c).println("Class " + className + " was previously defined.");
d209 1
a209 1
        if (!userClasses.defined(TreeConstants.Main))
d215 2
a216 4
            String className = c.getName().toString();
            String parentName = c.getParent().toString();
            if (!userClasses.defined(c.getParent()) && !basicClasses.defined(c.getParent())) {
                semantError(c).println("Class " + className + " inherits from an undefined class " + parentName + ".");
d229 1
a229 1
                semantError(getByName(s.toString())).println("Class " + s.toString() + ", or an ancestor of " + s.toString() + ", is involved in an inheritance cycle.");
d234 1
a234 1
     * Gets the class_c object with the specified namei from the lists
d239 3
a241 3
    public class_c getByName(String className) {
        class_c c = userClasses.getByName(className);
        return ((c == null) ? basicClasses.getByName(className) : c);
d250 2
a251 2
        if (!userClasses.defined(type))
            return basicClasses.defined(type);
d314 1
a314 1
	    private SymbolDigraph sg;
d318 1
a318 1
	        sg = new SymbolDigraph(userClasses.getLength() + basicClasses.getLength()); 
a322 1
    	        String className = c.getName().toString();
d325 1
a325 1
                        sg.addEdge(TreeConstants.Object_.toString(), className);
a335 2
    	            String className = c.getName().toString();
	                String parentName = c.getParent().toString();
d337 1
a337 1
	                sg.addEdge(parentName, className); 
d340 1
a340 1
	            semantError(c).println("Class " + className + ", or an ancestor of " + className + ", is involved in an inheritance cycle.");
d363 1
a363 1
	                    lst.add(getByName(sg.name(v)).name);
d376 1
a376 1
            int t = sg.index(type.toString());
d381 1
a381 1
                            lst.add(getByName(sg.name(w)).name);
@


1.16
log
@*** empty log message ***
@
text
@d223 5
a227 1

@


1.15
log
@*** empty log message ***
@
text
@d247 2
a248 2
//        if (type.equals(TreeConstants.SELF_TYPE))
  //          return true;
d302 1
a302 1
        if (type.equals(TreeConstants.SELF_TYPE))
d304 1
@


1.14
log
@*** empty log message ***
@
text
@d301 3
a303 1
    public Vector<AbstractSymbol> supertypes(AbstractSymbol type){
@


1.13
log
@*** empty log message ***
@
text
@d388 5
@


1.12
log
@*** empty log message ***
@
text
@a336 2
                    if (!c.getParent().equals(TreeConstants.Object_))
                        sg.addEdge(TreeConstants.Object_.toString(), className);
d370 1
a370 1
        * Returns ancestors in the increasing order of inheritance.
d378 1
a378 1
                if (paths.hasPathTo(t))
d380 1
a380 1
                        lst.add(getByName(sg.name(w)).name);
d382 1
@


1.11
log
@*** empty log message ***
@
text
@d247 2
@


1.10
log
@*** empty log message ***
@
text
@d227 2
a228 2
            for (class_c c : ig.cycle())
                semantError(c).println("Class " + c.getName() + ", or an ancestor of " + c.getName() + ", is involved in an inheritance cycle.");
d238 1
a238 1
    private class_c getByName(String className) {
d299 8
d313 16
d330 10
a339 6
	            class_c c = e.nextElement();
	            String className = c.getName().toString();
	            String parentName = c.getParent().toString();
	            try { sg.addEdge(parentName, className); }
	            catch(SelfLoopExistsException ex) {
	                semantError(c).println("Class " + className + ", or an ancestor of " + className + ", is involved in an inheritance cycle.");
a340 1
	            catch(ParallelEdgeExistsException ex) {}
d346 1
a350 1

d356 1
a356 1
	    public Iterable<class_c> cycle() {
d358 1
a358 1
	            Vector<class_c> lst = new Vector<class_c>();
d362 1
a362 1
	                    lst.add(getByName(sg.name(v)));
d369 30
a398 7

	    public boolean isAncestorOf(class_c c){
	            // To do: Implement
	        return false;
	    }
	}
}
@


1.9
log
@*** empty log message ***
@
text
@d9 2
a10 2
 * the inheritance graph.  You may use it or not as you like: it is only
 * here to provide a container for the supplied methods.  */
d19 1
a19 3
     * IO, Int, Bool, String).  Please note: as is this method does not
     * do anything useful; you will need to edit it to make if do what
     * you want.
a28 5
	// IMPORTANT: The results of the following expressions are
	// stored in local variables.  You will want to do something
	// with those variables at the end of this method to make this
	// code meaningful.

d176 7
d192 1
a192 2
        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
        {
d214 1
a214 2
        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
        {
d224 1
a224 1
        // if all is well construct a inheritance graph
a228 14

        // To do: Set isAnscestor provider
        

        //
    }


    public Classes getBasicClasses() {
        return basicClasses;
    }

    public Classes getUserClasses() {
            return userClasses;
d243 3
a252 7
    public void setMethodEnvironment() {
        for (Enumeration<class_c> e = userClasses.getElements(); e.hasMoreElements();) {
            class_c c = e.nextElement();
            // To do
        }
    }

d299 1
a299 2
	class InheritanceGraph
	{
d303 3
a305 4
	    InheritanceGraph(Classes userClasses, Classes basicClasses) {
	        sg = new SymbolDigraph(userClasses.getLength() + basicClasses.getLength()); // +1 for basic classes
	        for (Enumeration<class_c> e = userClasses.getElements(); e.hasMoreElements();)
	        {
d323 1
d328 1
d330 1
a330 2
	        if (hasCycle())
	        {
d332 1
a332 2
	            for (Iterator<Integer> i = cycleFinder.cycle().iterator(); i.hasNext();)
	            {
d342 1
a348 2


@


1.8
log
@*** empty log message ***
@
text
@d210 4
@


1.7
log
@*** empty log message ***
@
text
@d196 1
a196 1
            if (basicClasses.defined(className)) {
d200 1
a200 1
            else if (userClasses.defined(className)) {
d216 1
a216 1
            if (!userClasses.defined(parentName) && !basicClasses.defined(parentName)) {
d256 2
a257 2
        if (!userClasses.defined(type.getString()))
            return basicClasses.defined(type.getString());
@


1.6
log
@*** empty log message ***
@
text
@d223 1
a223 1
        ig = new InheritanceGraph(cls);
d320 3
a322 3
	    InheritanceGraph(Classes cls) {
	        sg = new SymbolDigraph(cls.getLength() + 1); // +1 for basic classes
	        for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
@


1.5
log
@*** empty log message ***
@
text
@d227 5
d255 7
d366 2
@


1.4
log
@*** empty log message ***
@
text
@d14 3
d175 6
a180 3
	/* Do somethind with Object_class, IO_class, Int_class,
           Bool_class, and Str_class here */

a182 2


d184 4
a187 3
    semantErrors = 0;
	errorStream = System.err;
    boolean redefinition = false;
d189 17
a205 16
    // To check for redefinition of basic classes
    Set<String> basicClasses = new HashSet<String>(5);
    basicClasses.add("Bool");
    basicClasses.add("Int");
    basicClasses.add("Object");
    basicClasses.add("IO");
    basicClasses.add("String");
    // To check for redefnition of user defined classes
    Set<String> userClasses = new HashSet<String>();
    for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
    {
        class_c c = e.nextElement();
        String className = c.getName().toString();
        if (basicClasses.contains(className)) {
            semantError(c).println("Redefinition of basic class " + className + ".");
            redefinition = true;
d207 13
a219 3
        else if (userClasses.contains(className)) {
            semantError(c).println("Class " + className + " was previously defined.");
            redefinition = true;
d221 6
a226 2
        else
            userClasses.add(className);
a227 2
    if (redefinition)
        return;
d229 3
a231 10
    // inheriting from an undefined class
    for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
    {
        class_c c = e.nextElement();
        String className = c.getName().toString();
        String parentName = c.getParent().toString();
        if (!userClasses.contains(parentName) && !basicClasses.contains(parentName)) {
            semantError(c).println("Class " + className + " inherits from an undefined class " + parentName + ".");
            return;
        }
d234 2
a235 28
    // The inheritance graph
    SymbolDigraph sg = new SymbolDigraph(cls.getLength() + 1); 
    for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();)
    {
        class_c c = e.nextElement();
        String className = c.getName().toString();
        String parentName = c.getParent().toString();
        try { sg.addEdge(parentName, className); }
        catch(SelfLoopExistsException ex) {
            semantError(c).println("Class " + className + ", or an ancestor of " + className + ", is involved in an inheritance cycle.");
        }
        catch(ParallelEdgeExistsException ex) {}
        catch(InvalidEdgeException ex) {
            System.out.println("Internal Error : Error constructing inheritance tree - \"" + ex + "\"");
            ex.printStackTrace();
            System.exit(1);
        }
    }
    // Checking for Cyclic inheritances
    DirectedCycleDFS cycleFinder = new DirectedCycleDFS(sg.G());
    if (cycleFinder.hasCycle()) {
        for (Iterator<Integer> i = cycleFinder.cycle().iterator(); i.hasNext();)
        {
            int v = i.next();
            if (i.hasNext()) {
                semantError(findByName(cls, sg.name(v))).println("Class " + sg.name(v) + ", or an ancestor of " + sg.name(v) + ", is involved in an inheritance cycle.");
            }
        }
d237 11
d250 5
a254 7
    private class_c findByName(Classes cls, String s) {
    for (Enumeration<class_c> e = cls.getElements(); e.hasMoreElements();) {
        class_c c = e.nextElement();
        if (c.getName().toString() == s) 
                return c;
    }
    return null;
d301 52
@


1.3
log
@*** empty log message ***
@
text
@d198 1
a198 1
            semantError(c).println("Redefiniton of basic class " + className + ".");
d217 1
a217 1
        if (!userClasses.contains(parentName)) {
@


1.2
log
@*** empty log message ***
@
text
@d230 2
a231 3
        try {
            sg.addEdge(parentName, className);
        } catch(SelfLoopExistsException ex) {
a232 1
            continue;
d236 1
a236 1
            System.out.println("Error constructing inheritance tree - \"" + ex + "\"");
d241 1
a241 3

    // Cyclic inheritances
    // construct the inheritance tree using a symbol digraph
a251 3
	
	
	/* fill this in */
@


1.1
log
@Initial revision
@
text
@d182 1
d184 1
a184 1
    // check for redefinitions
d191 2
a192 2
    Set<String> hashSet = new HashSet<String>();
    SymbolDigraph sg = new SymbolDigraph(cls.getLength() + 1); 
a196 1
        String parentName = c.getParent().toString();
d199 1
a199 1
            continue;
d201 1
a201 1
        if (hashSet.contains(className)){
d203 17
a219 1
            continue;
d221 9
a229 1
        hashSet.add(className);
d248 1
a248 2
        Iterator<Integer> i = cycleFinder.cycle().iterator();
        while (i.hasNext())
a252 1
                continue;
@
