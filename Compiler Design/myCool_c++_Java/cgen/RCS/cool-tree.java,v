head	1.46;
access;
symbols;
locks
	kempa:1.46; strict;
comment	@# @;


1.46
date	2013.03.14.01.12.42;	author kempa;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.10.06.22.46;	author kempa;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.10.04.08.00;	author kempa;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.10.03.33.47;	author kempa;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.09.10.03.17;	author kempa;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.07.02.55.38;	author kempa;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.06.14.36.12;	author kempa;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.06.13.30.20;	author kempa;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.06.13.09.59;	author kempa;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.03.18.40.52;	author kempa;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.03.03.05.43;	author kempa;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.02.08.27.26;	author kempa;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.02.08.23.35;	author kempa;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.02.07.47.20;	author kempa;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.01.14.02.12;	author kempa;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.01.09.58.12;	author kempa;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.01.07.49.01;	author kempa;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.01.05.57.43;	author kempa;	state Exp;
branches;
next	1.28;

1.28
date	2013.02.28.10.51.14;	author kempa;	state Exp;
branches;
next	1.27;

1.27
date	2013.02.28.10.46.08;	author kempa;	state Exp;
branches;
next	1.26;

1.26
date	2013.02.28.05.10.13;	author kempa;	state Exp;
branches;
next	1.25;

1.25
date	2013.02.27.16.23.05;	author kempa;	state Exp;
branches;
next	1.24;

1.24
date	2013.02.27.15.00.52;	author kempa;	state Exp;
branches;
next	1.23;

1.23
date	2013.02.27.14.34.47;	author kempa;	state Exp;
branches;
next	1.22;

1.22
date	2013.02.27.07.52.22;	author kempa;	state Exp;
branches;
next	1.21;

1.21
date	2013.02.27.05.56.16;	author kempa;	state Exp;
branches;
next	1.20;

1.20
date	2013.02.26.12.56.15;	author kempa;	state Exp;
branches;
next	1.19;

1.19
date	2013.02.26.12.44.38;	author kempa;	state Exp;
branches;
next	1.18;

1.18
date	2013.02.26.07.50.47;	author kempa;	state Exp;
branches;
next	1.17;

1.17
date	2013.02.25.16.43.31;	author kempa;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.25.13.38.11;	author kempa;	state Exp;
branches;
next	1.15;

1.15
date	2013.02.25.11.33.44;	author kempa;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.25.11.21.27;	author kempa;	state Exp;
branches;
next	1.13;

1.13
date	2013.02.25.10.57.29;	author kempa;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.24.10.28.44;	author kempa;	state Exp;
branches;
next	1.11;

1.11
date	2013.02.24.09.44.53;	author kempa;	state Exp;
branches;
next	1.10;

1.10
date	2013.02.24.06.55.55;	author kempa;	state Exp;
branches;
next	1.9;

1.9
date	2013.02.24.05.59.50;	author kempa;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.24.04.10.33;	author kempa;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.23.14.54.43;	author kempa;	state Exp;
branches;
next	1.6;

1.6
date	2013.02.23.11.35.28;	author kempa;	state Exp;
branches;
next	1.5;

1.5
date	2013.02.23.05.07.43;	author kempa;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.22.17.54.31;	author kempa;	state Exp;
branches;
next	1.3;

1.3
date	2013.02.22.16.35.20;	author kempa;	state Exp;
branches;
next	1.2;

1.2
date	2013.02.22.06.22.17;	author kempa;	state Exp;
branches;
next	1.1;

1.1
date	2013.02.12.09.21.42;	author kempa;	state Exp;
branches;
next	;


desc
@@


1.46
log
@58/63
@
text
@// -*- mode: java -*- 
//
// file: cool-tree.m4
//
// This file defines the AST
//
//////////////////////////////////////////////////////////

import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedList;
import java.io.PrintStream;
import java.util.Vector;

/** Defines simple phylum Program */
abstract class Program extends TreeNode
{
	protected Program(int lineNumber)
	{
		super(lineNumber);
	}

	public abstract void dump_with_types(PrintStream out, int n);

	public abstract void semant();

	public abstract void cgen(PrintStream s);

}

/** Defines simple phylum Class_ */
abstract class Class_ extends TreeNode
{
	protected Class_(int lineNumber)
	{
		super(lineNumber);
	}

	public abstract void dump_with_types(PrintStream out, int n);

	public abstract AbstractSymbol getName();

	public abstract AbstractSymbol getParent();

	public abstract AbstractSymbol getFilename();

	public abstract Features getFeatures();

}

/**
 * Defines list phylum Classes
 * <p>
 * See <a href="ListNode.html">ListNode</a> for full documentation.
 */
class Classes extends ListNode
{
	public final static Class elementClass = Class_.class;

	/** Returns class of this lists's elements */
	public Class getElementClass()
	{
		return elementClass;
	}

	protected Classes(int lineNumber, Vector elements)
	{
		super(lineNumber, elements);
	}

	/** Creates an empty "Classes" list */
	public Classes(int lineNumber)
	{
		super(lineNumber);
	}

	/** Appends "Class_" element to this list */
	public Classes appendElement(TreeNode elem)
	{
		addElement(elem);
		return this;
	}

	public TreeNode copy()
	{
		return new Classes(lineNumber, copyElements());
	}
}

/** Defines simple phylum Feature */
abstract class Feature extends TreeNode
{
	protected Feature(int lineNumber)
	{
		super(lineNumber);
	}

	public abstract void dump_with_types(PrintStream out, int n);

}

/**
 * Defines list phylum Features
 * <p>
 * See <a href="ListNode.html">ListNode</a> for full documentation.
 */
class Features extends ListNode
{
	public final static Class elementClass = Feature.class;

	/** Returns class of this lists's elements */
	public Class getElementClass()
	{
		return elementClass;
	}

	protected Features(int lineNumber, Vector elements)
	{
		super(lineNumber, elements);
	}

	/** Creates an empty "Features" list */
	public Features(int lineNumber)
	{
		super(lineNumber);
	}

	/** Appends "Feature" element to this list */
	public Features appendElement(TreeNode elem)
	{
		addElement(elem);
		return this;
	}

	public TreeNode copy()
	{
		return new Features(lineNumber, copyElements());
	}
}

/** Defines simple phylum Formal */
abstract class Formal extends TreeNode
{
	protected Formal(int lineNumber)
	{
		super(lineNumber);
	}

	public abstract void dump_with_types(PrintStream out, int n);

}

/**
 * Defines list phylum Formals
 * <p>
 * See <a href="ListNode.html">ListNode</a> for full documentation.
 */
class Formals extends ListNode
{
	public final static Class elementClass = Formal.class;

	/** Returns class of this lists's elements */
	public Class getElementClass()
	{
		return elementClass;
	}

	protected Formals(int lineNumber, Vector elements)
	{
		super(lineNumber, elements);
	}

	/** Creates an empty "Formals" list */
	public Formals(int lineNumber)
	{
		super(lineNumber);
	}

	/** Appends "Formal" element to this list */
	public Formals appendElement(TreeNode elem)
	{
		addElement(elem);
		return this;
	}

	public TreeNode copy()
	{
		return new Formals(lineNumber, copyElements());
	}
}

/** Defines simple phylum Expression */
abstract class Expression extends TreeNode
{
	protected Expression(int lineNumber)
	{
		super(lineNumber);
	}

	private AbstractSymbol type = null;

	public AbstractSymbol get_type()
	{
		return type;
	}

	public Expression set_type(AbstractSymbol s)
	{
		type = s;
		return this;
	}

	public abstract void dump_with_types(PrintStream out, int n);

	public void dump_type(PrintStream out, int n)
	{
		if (type != null)
		{
			out.println(Utilities.pad(n) + ": " + type.getString());
		}
		else
		{
			out.println(Utilities.pad(n) + ": _no_type");
		}
	}

	/**
	 * 
	 * @@param c Represents the class in which this expression lies
	 * @@param m Represents the method in which this expression lies
	 * @@param env
	 * @@param s
	 */
	public abstract void code(MethodNode mn, CgenClassTable env, PrintStream s);

}

/**
 * Defines list phylum Expressions
 * <p>
 * See <a href="ListNode.html">ListNode</a> for full documentation.
 */
class Expressions extends ListNode
{
	public final static Class elementClass = Expression.class;

	/** Returns class of this lists's elements */
	public Class getElementClass()
	{
		return elementClass;
	}

	protected Expressions(int lineNumber, Vector elements)
	{
		super(lineNumber, elements);
	}

	/** Creates an empty "Expressions" list */
	public Expressions(int lineNumber)
	{
		super(lineNumber);
	}

	/** Appends "Expression" element to this list */
	public Expressions appendElement(TreeNode elem)
	{
		addElement(elem);
		return this;
	}

	public TreeNode copy()
	{
		return new Expressions(lineNumber, copyElements());
	}
}

/** Defines simple phylum Case */
abstract class Case extends TreeNode
{
	protected Case(int lineNumber)
	{
		super(lineNumber);
	}

	public abstract void dump_with_types(PrintStream out, int n);

}

/**
 * Defines list phylum Cases
 * <p>
 * See <a href="ListNode.html">ListNode</a> for full documentation.
 */
class Cases extends ListNode
{
	public final static Class elementClass = Case.class;

	/** Returns class of this lists's elements */
	public Class getElementClass()
	{
		return elementClass;
	}

	protected Cases(int lineNumber, Vector elements)
	{
		super(lineNumber, elements);
	}

	/** Creates an empty "Cases" list */
	public Cases(int lineNumber)
	{
		super(lineNumber);
	}

	/** Appends "Case" element to this list */
	public Cases appendElement(TreeNode elem)
	{
		addElement(elem);
		return this;
	}

	public TreeNode copy()
	{
		return new Cases(lineNumber, copyElements());
	}
}

/**
 * Defines AST constructor 'program'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class program extends Program
{
	public Classes classes;

	/**
	 * Creates "program" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for classes
	 */
	public program(int lineNumber, Classes a1)
	{
		super(lineNumber);
		classes = a1;
	}

	public TreeNode copy()
	{
		return new program(lineNumber, (Classes) classes.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "program\n");
		classes.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_program");
		for (Enumeration e = classes.getElements(); e.hasMoreElements();)
		{
			((Class_) e.nextElement()).dump_with_types(out, n + 1);
		}
	}

	/**
	 * This method is the entry point to the semantic checker. You will
	 * need to complete it in programming assignment 4.
	 * <p>
	 * Your checker should do the following two things:
	 * <ol>
	 * <li>Check that the program is semantically correct
	 * <li>Decorate the abstract syntax tree with type information by setting
	 * the type field in each Expression node. (see tree.h)
	 * </ol>
	 * <p>
	 * You are free to first do (1) and make sure you catch all semantic errors.
	 * Part (2) can be done in a second stage when you want to test the complete
	 * compiler.
	 */
	public void semant()
	{
		/* ClassTable constructor may do some semantic analysis */
		ClassTable classTable = new ClassTable(classes);

		/* some semantic analysis code may go here */

		if (classTable.errors())
		{
			System.err.println("Compilation halted due to static semantic "
					+ "errors.");
			System.exit(1);
		}
	}

	/**
	 * This method is the entry point to the code generator. All of the work
	 * of the code generator takes place within CgenClassTable constructor.
	 * 
	 * @@param s the output stream
	 * @@see CgenClassTable
	 * */
	public void cgen(PrintStream s)
	{
		// spim wants comments to start with '#'
		s.print("# start of generated code\n");

		CgenClassTable codegen_classtable = new CgenClassTable(classes, s);

		s.print("\n# end of generated code\n");
	}

}

/**
 * Defines AST constructor 'class_'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class class_ extends Class_
{
	public AbstractSymbol name;
	public AbstractSymbol parent;
	public Features features;
	public AbstractSymbol filename;

	/**
	 * Creates "class_" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for parent
	 * @@param a2 initial value for features
	 * @@param a3 initial value for filename
	 */
	public class_(int lineNumber, AbstractSymbol a1, AbstractSymbol a2,
			Features a3, AbstractSymbol a4)
	{
		super(lineNumber);
		name = a1;
		parent = a2;
		features = a3;
		filename = a4;
	}

	public TreeNode copy()
	{
		return new class_(lineNumber, copy_AbstractSymbol(name),
				copy_AbstractSymbol(parent), (Features) features.copy(),
				copy_AbstractSymbol(filename));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "class_\n");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, parent);
		features.dump(out, n + 2);
		dump_AbstractSymbol(out, n + 2, filename);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_class");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, parent);
		out.print(Utilities.pad(n + 2) + "\"");
		Utilities.printEscapedString(out, filename.getString());
		out.println("\"\n" + Utilities.pad(n + 2) + "(");
		for (Enumeration e = features.getElements(); e.hasMoreElements();)
		{
			((Feature) e.nextElement()).dump_with_types(out, n + 2);
		}
		out.println(Utilities.pad(n + 2) + ")");
	}

	public AbstractSymbol getName()
	{
		return name;
	}

	public AbstractSymbol getParent()
	{
		return parent;
	}

	public AbstractSymbol getFilename()
	{
		return filename;
	}

	public Features getFeatures()
	{
		return features;
	}
}

/**
 * Defines AST constructor 'method'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class method extends Feature
{
	public AbstractSymbol name;
	public Formals formals;
	public AbstractSymbol return_type;
	public Expression expr;

	/**
	 * Creates "method" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for formals
	 * @@param a2 initial value for return_type
	 * @@param a3 initial value for expr
	 */
	public method(int lineNumber, AbstractSymbol a1, Formals a2,
			AbstractSymbol a3, Expression a4)
	{
		super(lineNumber);
		name = a1;
		formals = a2;
		return_type = a3;
		expr = a4;
	}

	public TreeNode copy()
	{
		return new method(lineNumber, copy_AbstractSymbol(name),
				(Formals) formals.copy(), copy_AbstractSymbol(return_type),
				(Expression) expr.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "method\n");
		dump_AbstractSymbol(out, n + 2, name);
		formals.dump(out, n + 2);
		dump_AbstractSymbol(out, n + 2, return_type);
		expr.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_method");
		dump_AbstractSymbol(out, n + 2, name);
		for (Enumeration e = formals.getElements(); e.hasMoreElements();)
		{
			((Formal) e.nextElement()).dump_with_types(out, n + 2);
		}
		dump_AbstractSymbol(out, n + 2, return_type);
		expr.dump_with_types(out, n + 2);
	}
}

/**
 * Defines AST constructor 'attr'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class attr extends Feature
{
	public AbstractSymbol name;
	public AbstractSymbol type_decl;
	public Expression init;

	/**
	 * Creates "attr" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for type_decl
	 * @@param a2 initial value for init
	 */
	public attr(int lineNumber, AbstractSymbol a1, AbstractSymbol a2,
			Expression a3)
	{
		super(lineNumber);
		name = a1;
		type_decl = a2;
		init = a3;
	}

	public TreeNode copy()
	{
		return new attr(lineNumber, copy_AbstractSymbol(name),
				copy_AbstractSymbol(type_decl), (Expression) init.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "attr\n");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
		init.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_attr");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
		init.dump_with_types(out, n + 2);
	}

}

/**
 * Defines AST constructor 'formal'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class formal extends Formal
{
	public AbstractSymbol name;
	public AbstractSymbol type_decl;

	/**
	 * Creates "formal" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for type_decl
	 */
	public formal(int lineNumber, AbstractSymbol a1, AbstractSymbol a2)
	{
		super(lineNumber);
		name = a1;
		type_decl = a2;
	}

	public TreeNode copy()
	{
		return new formal(lineNumber, copy_AbstractSymbol(name),
				copy_AbstractSymbol(type_decl));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "formal\n");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_formal");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
	}

}

/**
 * Defines AST constructor 'branch'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class branch extends Case
{
	public AbstractSymbol name;
	public AbstractSymbol type_decl;
	public Expression expr;

	/**
	 * Creates "branch" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for type_decl
	 * @@param a2 initial value for expr
	 */
	public branch(int lineNumber, AbstractSymbol a1, AbstractSymbol a2,
			Expression a3)
	{
		super(lineNumber);
		name = a1;
		type_decl = a2;
		expr = a3;
	}

	public TreeNode copy()
	{
		return new branch(lineNumber, copy_AbstractSymbol(name),
				copy_AbstractSymbol(type_decl), (Expression) expr.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "branch\n");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
		expr.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_branch");
		dump_AbstractSymbol(out, n + 2, name);
		dump_AbstractSymbol(out, n + 2, type_decl);
		expr.dump_with_types(out, n + 2);
	}

}

/**
 * Defines AST constructor 'assign'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class assign extends Expression
{
	protected AbstractSymbol name;
	protected Expression expr;

	/**
	 * Creates "assign" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 * @@param a1 initial value for expr
	 */
	public assign(int lineNumber, AbstractSymbol a1, Expression a2)
	{
		super(lineNumber);
		name = a1;
		expr = a2;
	}

	public TreeNode copy()
	{
		return new assign(lineNumber, copy_AbstractSymbol(name),
				(Expression) expr.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "assign\n");
		dump_AbstractSymbol(out, n + 2, name);
		expr.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_assign");
		dump_AbstractSymbol(out, n + 2, name);
		expr.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for the assign expression.
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Start - Assign expression");
		s.println();

		s.println("# Save self object");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the RHS and get the reference in $a0");
		expr.code(mn, env, s);
		s.println();

		s.println("# Get the address of the identifier");
		if (env.lookup(name) != null)
		{
			s.println("# The identifier is a local variable. Store relative to $fp");
			CgenSupport.emitStore(CgenSupport.ACC, (Integer) env.lookup(name),
					CgenSupport.FP, s);

			s.println("# Discard stored self object");
			CgenSupport.emitPop(CgenSupport.T1, mn, s);
		}
		else
		{
			s.println("# The identifier is an object attribute");

			s.println("# Temporarily cache the result");
			CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
			s.println();

			s.println("# Restore the self object");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			s.println();

			s.println("# Save the RHS");
			CgenSupport.emitPush(CgenSupport.T1, mn, s);

			s.println("# Class tag of invoking object");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
			CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);

			int aLabel[] = new int[env.aTab.get(name).size()];
			int endLabel = CgenSupport.getLabel();
			int nLabel = 0;
			for (Iterator<AttrNode> i = env.aTab.get(name).iterator(); i
					.hasNext(); nLabel++)
			{
				AttrNode attrNd = i.next();
				aLabel[nLabel] = CgenSupport.getLabel();
				CgenSupport.emitLoadImm(CgenSupport.T1, attrNd.classTag, s);
				CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1,
						aLabel[nLabel], s);
			}

			int nItems = 0;

			nItems = mn.nItems;
			nLabel = 0;
			for (Iterator<AttrNode> i = env.aTab.get(name).iterator(); i
					.hasNext(); nLabel++)
			{

				mn.nItems = nItems;
				AttrNode attrNd = i.next();
				CgenSupport.emitLabelDef(aLabel[nLabel], s);
				CgenSupport.emitPop(CgenSupport.ACC, mn, s);
				CgenSupport.emitPop(CgenSupport.T1, mn, s);
				CgenSupport.emitStore(CgenSupport.T1, attrNd.offset,
						CgenSupport.ACC, s);
				CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);

				CgenSupport.emitBranch(endLabel, s);
			}
			CgenSupport.emitLabelDef(endLabel, s);

		}

		/*
		 * offsetAddress a = Utilities.getAddress(name, mn.nd, env);
		 * 
		 * s.println("# Store the result in the location of the variable");
		 * CgenSupport.emitStore(CgenSupport.T1, a.offset, a.reg, s);
		 * s.println();
		 * 
		 * s.println("# De-cache the result. It must be in $a0");
		 * CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);
		 */

		s.println("# End of assign expression");
		s.println();
	}
}

/**
 * Defines AST constructor 'static_dispatch'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class static_dispatch extends Expression
{
	public Expression expr;
	public AbstractSymbol type_name;
	public AbstractSymbol name;
	public Expressions actual;

	/**
	 * Creates "static_dispatch" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for expr
	 * @@param a1 initial value for type_name
	 * @@param a2 initial value for name
	 * @@param a3 initial value for actual
	 */
	public static_dispatch(int lineNumber, Expression a1, AbstractSymbol a2,
			AbstractSymbol a3, Expressions a4)
	{
		super(lineNumber);
		expr = a1;
		type_name = a2;
		name = a3;
		actual = a4;
	}

	public TreeNode copy()
	{
		return new static_dispatch(lineNumber, (Expression) expr.copy(),
				copy_AbstractSymbol(type_name), copy_AbstractSymbol(name),
				(Expressions) actual.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "static_dispatch\n");
		expr.dump(out, n + 2);
		dump_AbstractSymbol(out, n + 2, type_name);
		dump_AbstractSymbol(out, n + 2, name);
		actual.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_static_dispatch");
		expr.dump_with_types(out, n + 2);
		dump_AbstractSymbol(out, n + 2, type_name);
		dump_AbstractSymbol(out, n + 2, name);
		out.println(Utilities.pad(n + 2) + "(");
		for (Enumeration e = actual.getElements(); e.hasMoreElements();)
		{
			((Expression) e.nextElement()).dump_with_types(out, n + 2);
		}
		out.println(Utilities.pad(n + 2) + ")");
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		int voidLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# Static Method dispatch\n");

		s.println("# Save FP");
		CgenSupport.emitPush(CgenSupport.FP, mn, s);
		s.println();

		for (Enumeration e = actual.getElements(); e.hasMoreElements();)
		{
			s.println("# Save self");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
			s.println();

			Expression ex = (Expression) e.nextElement();
			s.println("# Evaluate actual argument and get it in in $a0");
			ex.code(mn, env, s);
			s.println();

			s.println("# Temporarily cache evaluated argument");
			CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
			s.println();

			s.println("# Restore self");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			s.println();

			s.println("# Push argument in Stack");
			CgenSupport.emitPush(CgenSupport.T1, mn, s);
			s.println();
		}

		s.println("# Evaluate invoking object and Get it in $a0");
		expr.code(mn, env, s);
		s.println();

		int nItems = 0;

		{
			s.println("# Test if invoking object is void");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
			CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
			CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG,
					s);
			nItems = mn.nItems;
			CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, voidLabel, s);
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		}

		s.println("# Get reference to dispatch Table");
		CgenSupport.emitFetchDispTab(CgenSupport.T1, CgenSupport.ACC, s);

		CgenNode nd = (CgenNode) (env.lookup(type_name));
		MethodNode m1 = null;
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator(); i.hasNext();)
		{
			m1 = i.next();
			if (m1.nd.equals(nd))
				break;
		}

		CgenSupport.emitLoad(CgenSupport.T1, m1.offset, CgenSupport.T1, s);
		s.println();

		s.println("# Dispatch");
		CgenSupport.emitJalr(CgenSupport.T1, s);
		s.println();

		// The arguments of this AR will be popped by the
		// callee
		mn.nItems -= actual.getLength();
		s.println("# Restore FP");
		CgenSupport.emitPop(CgenSupport.FP, mn, s);
		s.println();
		CgenSupport.emitBranch(endLabel, s);

		mn.nItems = nItems - actual.getLength();
		{
			CgenSupport.emitLabelDef(voidLabel, s);
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			CgenSupport.emitLoadString(CgenSupport.ACC,
					(StringSymbol) AbstractTable.stringtable
							.lookup(mn.nd.filename.toString()), s);
			CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
			CgenSupport.emitJal("_dispatch_abort", s);
			CgenSupport.emitPop(CgenSupport.FP, mn, s);
		}

		CgenSupport.emitLabelDef(endLabel, s);
	}

}

/**
 * Defines AST constructor 'dispatch'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class dispatch extends Expression
{
	public Expression expr;
	public AbstractSymbol name;
	public Expressions actual;

	/**
	 * Creates "dispatch" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for expr
	 * @@param a1 initial value for name
	 * @@param a2 initial value for actual
	 */
	public dispatch(int lineNumber, Expression a1, AbstractSymbol a2,
			Expressions a3)
	{
		super(lineNumber);
		expr = a1;
		name = a2;
		actual = a3;
	}

	public TreeNode copy()
	{
		return new dispatch(lineNumber, (Expression) expr.copy(),
				copy_AbstractSymbol(name), (Expressions) actual.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "dispatch\n");
		expr.dump(out, n + 2);
		dump_AbstractSymbol(out, n + 2, name);
		actual.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_dispatch");
		expr.dump_with_types(out, n + 2);
		dump_AbstractSymbol(out, n + 2, name);
		out.println(Utilities.pad(n + 2) + "(");
		for (Enumeration e = actual.getElements(); e.hasMoreElements();)
		{
			((Expression) e.nextElement()).dump_with_types(out, n + 2);
		}
		out.println(Utilities.pad(n + 2) + ")");
		dump_type(out, n);
	}

	public CgenNode getNode(CgenNode root, AbstractSymbol name)
	{
		LinkedList<CgenNode> q = new LinkedList<CgenNode>();

		q.add(root);

		while (!q.isEmpty())
		{
			CgenNode nd = q.remove();
			if (nd.name.equals(name))
				return nd;
			for (Enumeration e = nd.getChildren(); e.hasMoreElements();)
				q.add((CgenNode) e.nextElement());
		}
		return null;
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		int notVoidLabel = CgenSupport.getLabel();
		int nItems = 0;

		s.println("# Method dispatch\n");

		s.println("# Save FP");
		CgenSupport.emitPush(CgenSupport.FP, mn, s);
		s.println();

		s.println("# Push Arguments");
		for (Enumeration e = actual.getElements(); e.hasMoreElements();)
		{
			s.println("# Save self");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
			s.println();

			Expression ex = (Expression) e.nextElement();
			s.println("# Evaluate actual argument and get it in in $a0");
			ex.code(mn, env, s);
			s.println();

			s.println("# Temporarily cache evaluated argument");
			CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
			s.println();

			s.println("# Restore self");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			s.println();

			s.println("# Push argument in Stack");
			CgenSupport.emitPush(CgenSupport.T1, mn, s);
			s.println();
		}

		s.println("# Evaluate invoking object and Get it in $a0");
		expr.code(mn, env, s);
		s.println();

		s.println("# Save it");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Need to check if the invoking object is void");
		s.println("# Fetch its classtag");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println("# Get the classtag of void");
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG, s);
		s.println("# The test. Is the invoking object not void?");
		s.println("# If yes, branch to label" + notVoidLabel);
		CgenSupport.emitBne(CgenSupport.ACC, CgenSupport.T1, notVoidLabel, s);
		s.println("# Else, invoking object is void.");

		s.println("# Void ");
		nItems = mn.nItems; // Incomplete : Causes infinite looping in GC
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		CgenSupport.emitLoadString(CgenSupport.ACC,
				(StringSymbol) AbstractTable.stringtable.lookup(mn.nd.filename
						.toString()), s);
		CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
		CgenSupport.emitJal("_dispatch_abort", s);
		CgenSupport.emitPop(CgenSupport.FP, mn, s);
		mn.nItems = nItems; // Incomplete: Causes infinite looping in GC

		s.println("# Not void");
		CgenSupport.emitLabelDef(notVoidLabel, s);
		s.println("# Restore the invoking object");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();
		s.println("# Determine the dispatch based on the "
				+ "type of the self object");
		s.println();
		s.println("# Save the invoking object");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println("# Get the class tag of the invoking object");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		Integer label[] = new Integer[env.mTab.get(name).size()];
		int k = 0;
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator(); i
				.hasNext(); k++)
		{
			MethodNode m1 = i.next();
			s.println("# Class tag of " + m1.nd.name);
			CgenSupport.emitLoadImm(CgenSupport.T1, m1.nd.classTag, s);
			label[k] = CgenSupport.getLabel();
			CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, label[k], s);
		}
		s.println();

		nItems = mn.nItems;
		int dispatchLabel = CgenSupport.getLabel();
		int j = 0;
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator(); i
				.hasNext(); j++)
		{

			mn.nItems = nItems;
			MethodNode m1 = i.next();
			s.println("# Dispatch for " + m1.nd.name + "." + m1.m.name);
			CgenSupport.emitLabelDef(label[j], s);
			s.println("# Restore the invoking object");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			s.println("# Dispatch table of invoking object");
			CgenSupport.emitFetchDispTab(CgenSupport.T1, CgenSupport.ACC, s);
			s.println("# Address of dynamic dispatch");
			CgenSupport.emitLoad(CgenSupport.T1, m1.offset, CgenSupport.T1, s);
			CgenSupport.emitBranch(dispatchLabel, s);
		}
		CgenSupport.emitLabelDef(dispatchLabel, s);

		s.println("# Dispatch");
		CgenSupport.emitJalr(CgenSupport.T1, s);
		s.println();

		// The arguments of this AR will be popped by the
		// callee
		mn.nItems -= actual.getLength();
		s.println("# Restore FP");
		CgenSupport.emitPop(CgenSupport.FP, mn, s);
		s.println();
	}
}

/**
 * Defines AST constructor 'cond'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class cond extends Expression
{
	public Expression pred;
	public Expression then_exp;
	public Expression else_exp;

	/**
	 * Creates "cond" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for pred
	 * @@param a1 initial value for then_exp
	 * @@param a2 initial value for else_exp
	 */
	public cond(int lineNumber, Expression a1, Expression a2, Expression a3)
	{
		super(lineNumber);
		pred = a1;
		then_exp = a2;
		else_exp = a3;
	}

	public TreeNode copy()
	{
		return new cond(lineNumber, (Expression) pred.copy(),
				(Expression) then_exp.copy(), (Expression) else_exp.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "cond\n");
		pred.dump(out, n + 2);
		then_exp.dump(out, n + 2);
		else_exp.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_cond");
		pred.dump_with_types(out, n + 2);
		then_exp.dump_with_types(out, n + 2);
		else_exp.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)
	{
		s.println("# If-then-else");
		s.println();

		int elseLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# Save self object before evaluating predicate. ");
		s.println("# Will need it to evaluate then-expression and else-expression");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate predicate and get reference in $a0");
		pred.code(mn, env, s);
		s.println();

		s.println("# Fetch the bool value of the object");
		CgenSupport.emitFetchBool(CgenSupport.ACC, CgenSupport.ACC, s);

		s.println("# Get reference to 'false' constant");
		CgenSupport.emitLoadAddress(CgenSupport.T1,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		CgenSupport.emitFetchBool(CgenSupport.T1, CgenSupport.T1, s);
		s.println();

		s.println("# The test. Did the predicate evaluate to 'false'?");
		s.println("# If it did jump to label" + elseLabel);
		CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, elseLabel, s);
		s.println();

		// Save the number of items in the current AR
		// This is needed to restore the same while generating code for the else
		// branch
		int nItems = 0;

		nItems = mn.nItems;
		s.println("# If-Then Branch");
		s.println("# Retrieve self object before evaluating the then-expr");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the then-expr and get reference in $a0");
		then_exp.code(mn, env, s);
		s.println();

		s.println("# End of if-then. Branch to label" + endLabel);
		CgenSupport.emitBranch(endLabel, s);
		s.println();

		mn.nItems = nItems;
		s.println("# The else branch");
		CgenSupport.emitLabelDef(elseLabel, s);
		s.println();

		s.println("# Retrieve self object before evaluating the else-expr");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the else-expr and get reference in $a0");
		else_exp.code(mn, env, s);
		s.println();

		s.println("# End of if-then-else");
		CgenSupport.emitLabelDef(endLabel, s);
		s.println();
	}

}

/**
 * Defines AST constructor 'loop'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class loop extends Expression
{
	public Expression pred;
	public Expression body;

	/**
	 * Creates "loop" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for pred
	 * @@param a1 initial value for body
	 */
	public loop(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		pred = a1;
		body = a2;
	}

	public TreeNode copy()
	{
		return new loop(lineNumber, (Expression) pred.copy(),
				(Expression) body.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "loop\n");
		pred.dump(out, n + 2);
		body.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_loop");
		pred.dump_with_types(out, n + 2);
		body.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# while loop");
		s.println();

		int endLabel = CgenSupport.getLabel();
		int loopLabel = CgenSupport.getLabel();

		s.println("# Save self object");
		s.println("# Will need it to evaluate the pred in the first iteration");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Loop");
		CgenSupport.emitLabelDef(loopLabel, s);
		s.println();

		s.println("# Retrieve self object before evaluating the predicate");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Save self object before evaluating predicate.");
		s.println("# Will need it to evaluate the body of the loop");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate predicate and get reference in $a0");
		pred.code(mn, env, s);
		CgenSupport.emitFetchBool(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println();

		s.println("# Get reference to 'false' constant");
		CgenSupport.emitLoadAddress(CgenSupport.T1,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		CgenSupport.emitFetchBool(CgenSupport.T1, CgenSupport.T1, s);
		s.println();

		s.println("# The test. Did the predicate evaluate to 'false'?");
		s.println("# If it did jump to label" + endLabel);
		CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, endLabel, s);
		s.println();

		s.println("# Retrieve self object before evaluating the body");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Save self object.");
		s.println("# Will need it to evaluate the pred in the next iteration");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the body and get reference in $a0");
		body.code(mn, env, s);
		s.println();

		s.println("# Go back to label" + loopLabel
				+ " to check if predicate is false");
		CgenSupport.emitBranch(loopLabel, s);
		s.println();

		s.println("# End of loop.");
		CgenSupport.emitLabelDef(endLabel, s);

		s.println("# Retrieve self object to restore the SP");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Set return value to void");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.VOIDCONST_PREFIX, s);
		s.println();
	}

}

/**
 * Defines AST constructor 'typcase'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class typcase extends Expression
{
	public Expression expr;
	public Cases cases;

	/**
	 * Creates "typcase" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for expr
	 * @@param a1 initial value for cases
	 */
	public typcase(int lineNumber, Expression a1, Cases a2)
	{
		super(lineNumber);
		expr = a1;
		cases = a2;
	}

	public TreeNode copy()
	{
		return new typcase(lineNumber, (Expression) expr.copy(),
				(Cases) cases.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "typcase\n");
		expr.dump(out, n + 2);
		cases.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_typcase");
		expr.dump_with_types(out, n + 2);
		for (Enumeration e = cases.getElements(); e.hasMoreElements();)
		{
			((Case) e.nextElement()).dump_with_types(out, n + 2);
		}
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		int nItems = 0;
		int notVoidLabel = CgenSupport.getLabel();

		s.println("# Case expression");
		s.println();

		s.println("# Save self. Needed while evaluating the LUB branch");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the case expression");
		expr.code(mn, env, s);

		s.println("# Need to check if the evaluated expression is void");
		s.println();

		s.println("# Save it");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println("# Fetch its classtag");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println("# Get the classtag of void");
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG, s);
		s.println("# The test. Is the evaluated expression not void?");
		s.println("# If yes, branch to label" + notVoidLabel);
		CgenSupport.emitBne(CgenSupport.ACC, CgenSupport.T1, notVoidLabel, s);
		s.println("# Else, evaluated expression is void.");
		CgenSupport.emitLoadString(CgenSupport.ACC,
				(StringSymbol) AbstractTable.stringtable.lookup(mn.nd.filename
						.toString()), s);
		CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
		CgenSupport.emitJal("_case_abort2", s);
		s.println();

		CgenSupport.emitLabelDef(notVoidLabel, s);

		s.println("# Restore the evaluated expression");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println("# Save the evaluated value.");
		s.println("# Will need to bind it to the identifier of one of the branches");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println("# Class tag of the case expression");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);

		// Code to jump to a particular branch of execution based on the
		// dynamic type of the case-expression
		// Once this is generated, we can generate code to find out
		// which type among all case-branches is the LUB of the dynamic type.
		int typeLabel[] = new int[env.caseTab.size()];
		int n = 0;
		for (Iterator<Integer> i = env.caseTab.keySet().iterator(); i.hasNext(); n++)
		{
			int classTag = i.next();
			CgenSupport.emitLoadImm(CgenSupport.T1, classTag, s);
			typeLabel[n] = CgenSupport.getLabel();
			CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, typeLabel[n],
					s);
		}
		// Incomplete
		// CgenSupport.emitAbort();

		// Code to get the LUB of the dynamic type of the case expression
		int branchLabel[] = new int[cases.getLength()];
		for (int i = 0; i < cases.getLength(); i++)
			branchLabel[i] = CgenSupport.getLabel();
		n = 0;
		for (Iterator<LinkedList<Integer>> i = env.caseTab.values().iterator(); i
				.hasNext(); n++)
		{
			CgenSupport.emitLabelDef(typeLabel[n], s);

			LinkedList<Integer> lst = i.next();

			for (Iterator<Integer> k = lst.iterator(); k.hasNext();)
			{
				int classTag = k.next();
				CgenSupport.emitLoadImm(CgenSupport.ACC, classTag, s);
				int m = 0;
				for (Enumeration e = cases.getElements(); e.hasMoreElements(); m++)
				{
					branch b = (branch) e.nextElement();
					CgenSupport.emitLoadImm(CgenSupport.T1,
							((CgenNode) env.lookup(b.type_decl)).classTag, s);
					CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1,
							branchLabel[m], s);
				}
			}
			nItems = mn.nItems;
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			CgenSupport.emitJal("_case_abort", s);
			mn.nItems = nItems;
		}

		// Code for each branch of the case expression
		int endLabel = CgenSupport.getLabel();
		n = 0;
		if (mn != null)
			nItems = mn.nItems;
		for (Enumeration e = cases.getElements(); e.hasMoreElements(); n++)
		{
			branch b = (branch) e.nextElement();

			env.enterScope();

			if (mn != null)
				mn.nItems = nItems;
			CgenSupport.emitLabelDef(branchLabel[n], s);
			s.println("# Temporarily cache the evaluated variable");
			CgenSupport.emitPop(CgenSupport.T1, mn, s);

			s.println("# Restore self");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);

			s.println("# Save the case variable in the stack");
			CgenSupport.emitPush(CgenSupport.T1, mn, s);
			// The offset is negative as the location of local variables are
			// below
			// the FP
			env.addId(b.name, -(mn.nItems - 1));

			b.expr.code(mn, env, s);

			s.println("# Discard case variable");
			CgenSupport.emitPop(CgenSupport.T1, mn, s);
			env.exitScope();
			CgenSupport.emitBranch(endLabel, s);
		}

		CgenSupport.emitLabelDef(endLabel, s);
	}

}

/**
 * Defines AST constructor 'block'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class block extends Expression
{
	public Expressions body;

	/**
	 * Creates "block" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for body
	 */
	public block(int lineNumber, Expressions a1)
	{
		super(lineNumber);
		body = a1;
	}

	public TreeNode copy()
	{
		return new block(lineNumber, (Expressions) body.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "block\n");
		body.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_block");
		for (Enumeration e = body.getElements(); e.hasMoreElements();)
		{
			((Expression) e.nextElement()).dump_with_types(out, n + 2);
		}
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Start of block");
		s.println();

		int n = 0;
		for (Enumeration e = body.getElements(); e.hasMoreElements(); n++)
			e.nextElement();

		Enumeration e = body.getElements();
		for (; n > 1; n--)
		{
			s.println("# Save self object before evaluating this expression.");
			s.println("# Will need it to evaluate the subsequent expressions");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
			s.println();

			s.println("# Evaluate the expression and "
					+ "get the reference in $a0");
			((Expression) (e.nextElement())).code(mn, env, s);
			s.println();

			s.println("# Retrieve self object before evaluating the next "
					+ "expression");
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			s.println();
		}
		s.println("# Evaluate the last expression and "
				+ "get the reference in $a0");
		((Expression) (e.nextElement())).code(mn, env, s);
		s.println();

		s.println("# End of block");
		s.println();
	}
}

/**
 * Defines AST constructor 'let'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class let extends Expression
{
	public AbstractSymbol identifier;
	public AbstractSymbol type_decl;
	public Expression init;
	public Expression body;

	/**
	 * Creates "let" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for identifier
	 * @@param a1 initial value for type_decl
	 * @@param a2 initial value for init
	 * @@param a3 initial value for body
	 */
	public let(int lineNumber, AbstractSymbol a1, AbstractSymbol a2,
			Expression a3, Expression a4)
	{
		super(lineNumber);
		identifier = a1;
		type_decl = a2;
		init = a3;
		body = a4;
	}

	public TreeNode copy()
	{
		return new let(lineNumber, copy_AbstractSymbol(identifier),
				copy_AbstractSymbol(type_decl), (Expression) init.copy(),
				(Expression) body.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "let\n");
		dump_AbstractSymbol(out, n + 2, identifier);
		dump_AbstractSymbol(out, n + 2, type_decl);
		init.dump(out, n + 2);
		body.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_let");
		dump_AbstractSymbol(out, n + 2, identifier);
		dump_AbstractSymbol(out, n + 2, type_decl);
		init.dump_with_types(out, n + 2);
		body.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{

		s.println("# let expression");
		s.println();

		env.enterScope();

		s.println("# Save the self object before evaluating the "
				+ "initializer.");
		s.println("# Will need it while evaluating the body of the let");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		// Hack. Incomplete
		if (init.getClass().toString().equals("class no_expr"))
		{
			s.println("# No Initializer. Get the reference to the default "
					+ "value in $a0 ");
			CgenSupport.emitLoadAddress(CgenSupport.ACC,
					Utilities.getDefaultObjectAddress(type_decl), s);
			s.println();
		}
		else
		{
			s.println("# Evaluate the initializer and get the reference in "
					+ "$a0");
			init.code(mn, env, s);
			s.println();
		}

		s.println("# Temporarily hold the let identifier");
		CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore the self object");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Save the let variable in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);
		// The offset is negative as the location of local variables are below
		// the FP
		env.addId(identifier, -(mn.nItems - 1));
		s.println();

		s.println("# Evaluate let-body and get the reference in $a0");
		body.code(mn, env, s);
		s.println();

		s.println("# Remove the let variable introduced");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		env.exitScope();
		s.println();

		s.println("# let expression ends");
	}

}

/**
 * Defines AST constructor 'plus'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class plus extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "plus" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public plus(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new plus(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "plus\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_plus");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# + expression");
		s.println();

		s.println("#Save reference to self object.");
		s.println("# Needed while evaluating the second operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# evaluate the first operand and get reference in $a0");
		e1.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);

		s.println("# Restore the self object before evaluating the second operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);

		s.println("# Save the value of the first operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);

		s.println("# evaluate the second operand and get reference in $a0");
		e2.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);

		s.println("# Restore the value of the first operand from the stack");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);

		s.println("# Compute and then save result in stack");
		CgenSupport
				.emitAdd(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# Create new object to store the result");
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, mn, s);

		s.println("# Store result in new object");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		CgenSupport.emitStoreInt(CgenSupport.T1, CgenSupport.ACC, s);
	}
}

/**
 * Defines AST constructor 'sub'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class sub extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "sub" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public sub(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new sub(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "sub\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_sub");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# - expression");
		s.println();

		s.println("#Save reference to self object.");
		s.println("# Needed while evaluating the second operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# evaluate the first operand and get reference in $a0");
		e1.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);

		s.println("# Restore the self object before evaluating the second operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);

		s.println("# Save the value of the first operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);

		s.println("# evaluate the second operand and get reference in $a0");
		e2.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);

		s.println("# Restore the value of the first operand from the stack");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);

		s.println("# Compute and then save result in stack");
		CgenSupport
				.emitSub(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# Create new object to store the result");
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, mn, s);

		s.println("# Store result in new object");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		CgenSupport.emitStoreInt(CgenSupport.T1, CgenSupport.ACC, s);
	}

}

/**
 * Defines AST constructor 'mul'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class mul extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "mul" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public mul(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new mul(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "mul\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_mul");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# * expression");
		s.println();

		s.println("#Save reference to self object.");
		s.println("# Needed while evaluating the second operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# evaluate the first operand and get reference in $a0");
		e1.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);

		s.println("# Restore the self object before evaluating the second operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);

		s.println("# Save the value of the first operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);

		s.println("# evaluate the second operand and get reference in $a0");
		e2.code(mn, env, s);

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);

		s.println("# Restore the value of the first operand from the stack");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);

		s.println("# Compute and then save result in stack");
		CgenSupport
				.emitMul(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);

		s.println("# Create new object to store the result");
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, mn, s);

		s.println("# Store result in new object");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		CgenSupport.emitStoreInt(CgenSupport.T1, CgenSupport.ACC, s);

	}

}

/**
 * Defines AST constructor 'divide'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class divide extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "divide" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public divide(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new divide(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "divide\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_divide");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# / expression");
		s.println();

		s.println("#Save reference to self object.");
		s.println("# Needed while evaluating the second operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# evaluate the first operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore the self object before evaluating the second operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Save the value of the first operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);
		s.println();

		s.println("# evaluate the second operand and get reference in $a0");
		e2.code(mn, env, s);
		s.println();

		s.println("# Get the value of the first operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore the value of the first operand from the stack");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		s.println();

		s.println("# Compute and then save result in stack");
		CgenSupport
				.emitDiv(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Create new object to store the result");
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, mn, s);
		s.println();

		s.println("# Store result in new object");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		CgenSupport.emitStoreInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();
	}
}

/**
 * Defines AST constructor 'neg'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class neg extends Expression
{
	public Expression e1;

	/**
	 * Creates "neg" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 */
	public neg(int lineNumber, Expression a1)
	{
		super(lineNumber);
		e1 = a1;
	}

	public TreeNode copy()
	{
		return new neg(lineNumber, (Expression) e1.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "neg\n");
		e1.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_neg");
		e1.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# neg expression");
		s.println();

		s.println("# Evaluate the operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("# Negate the value and save it");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);
		CgenSupport.emitNeg(CgenSupport.ACC, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("#Create new integer object");
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, mn, s);
		s.println();

		s.println("# Retrieve the negated value");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		s.println();

		s.println("# Initialize the new object with it");
		CgenSupport.emitStoreInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# End of neg expression");
		s.println();
	}

}

/**
 * Defines AST constructor 'lt'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class lt extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "lt" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public lt(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new lt(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "lt\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_lt");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# < expression");
		s.println("# ");
		int trueLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# Save self object. Needed during evaluation of the 2nd "
				+ "operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("#Evaluate 1st operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("#Get value of 1st operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore self object before evaluation of the 2nd "
				+ "operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("#Save the value of the 1st operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);
		s.println();

		s.println("# Evaluate the 2nd operand and get reference in $a0");
		e2.code(mn, env, s);
		s.println("#");

		s.println("# Get the value of the 2nd operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore the value of the first operand");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		s.println();

		s.println("# The test. Branch to label" + trueLabel + " if true");
		CgenSupport.emitBlt(CgenSupport.T1, CgenSupport.ACC, trueLabel, s);
		s.println();

		/** False **/
		s.println("# False part");
		s.println("# Set return value to the boolean constant, false");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		s.println();

		s.println("#Branch to the end, label" + endLabel);
		CgenSupport.emitBranch(endLabel, s);
		s.println("#");

		s.println("# True part");
		CgenSupport.emitLabelDef(trueLabel, s);
		s.println();

		s.println("# Set return value to the boolean constant, true");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
		s.println();

		s.println("# End of < expression");
		CgenSupport.emitLabelDef(endLabel, s);
		s.println();

	}
}

/**
 * Defines AST constructor 'eq'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class eq extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "eq" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public eq(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new eq(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "eq\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_eq");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		int trueLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# '=' expression");

		s.println("# Save self object before evaluating the LHS.");
		s.println("# Will need it while evaluating the RHS");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Evaluate the 1st operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("# Temporarily cache the 1st operand");
		CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);

		s.println("# Restore self object to evaluate the 2nd operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Save the first operand");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);
		s.println();

		s.println("# Evaluate the 2nd operand and get reference in $a0");
		e2.code(mn, env, s);
		s.println();

		s.println("# Move 2nd operand into $t2 to do the equality testing");
		CgenSupport.emitMove(CgenSupport.T2, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore 1st operand into $t1 to do the equality testing");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		s.println();
		s.println("# Are both operands the same object?. If yes go to label"
				+ trueLabel);
		CgenSupport.emitBeq(CgenSupport.T1, CgenSupport.T2, trueLabel, s);
		s.println();

		s.println("# equality test");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
		CgenSupport.emitLoadAddress(CgenSupport.A1,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		CgenSupport.emitJal("equality_test", s);
		CgenSupport.emitBranch(endLabel, s);

		s.println("# True Label. Return true");
		CgenSupport.emitLabelDef(trueLabel, s);
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);

		CgenSupport.emitLabelDef(endLabel, s);
	}

}

/**
 * Defines AST constructor 'leq'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class leq extends Expression
{
	public Expression e1;
	public Expression e2;

	/**
	 * Creates "leq" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 * @@param a1 initial value for e2
	 */
	public leq(int lineNumber, Expression a1, Expression a2)
	{
		super(lineNumber);
		e1 = a1;
		e2 = a2;
	}

	public TreeNode copy()
	{
		return new leq(lineNumber, (Expression) e1.copy(),
				(Expression) e2.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "leq\n");
		e1.dump(out, n + 2);
		e2.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_leq");
		e1.dump_with_types(out, n + 2);
		e2.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# <= expression");
		s.println("# ");
		int trueLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# Save self object. Needed during evaluation of the 2nd "
				+ "operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("#Evaluate 1st operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("#Get value of 1st operand");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore self object before evaluation of the 2nd "
				+ "operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("#Save the value of the 1st operand in the stack");
		CgenSupport.emitPush(CgenSupport.T1, mn, s);
		s.println();

		s.println("# Evaluate the 2nd operand and get reference in $a0");
		e2.code(mn, env, s);
		s.println("#");

		s.println("# Get the value of the 2nd operand");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println();

		s.println("# Restore the value of the first operand");
		CgenSupport.emitPop(CgenSupport.T1, mn, s);
		s.println();

		s.println("# The test. Branch to label" + trueLabel + " if true");
		CgenSupport.emitBleq(CgenSupport.T1, CgenSupport.ACC, trueLabel, s);
		s.println();

		/** False **/
		s.println("# False part");
		s.println("# Set return value to the boolean constant, false");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		s.println();

		s.println("#Branch to the end, label" + endLabel);
		CgenSupport.emitBranch(endLabel, s);
		s.println("#");

		s.println("# True part");
		CgenSupport.emitLabelDef(trueLabel, s);
		s.println();

		s.println("# Set return value to the boolean constant, true");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
		s.println();

		s.println("# End of < expression");
		CgenSupport.emitLabelDef(endLabel, s);
		s.println();
	}

}

/**
 * Defines AST constructor 'comp'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class comp extends Expression
{
	public Expression e1;

	/**
	 * Creates "comp" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 */
	public comp(int lineNumber, Expression a1)
	{
		super(lineNumber);
		e1 = a1;
	}

	public TreeNode copy()
	{
		return new comp(lineNumber, (Expression) e1.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "comp\n");
		e1.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_comp");
		e1.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Complement expression");
		s.println();

		int endLabel = CgenSupport.getLabel();
		int returnFalseLabel = CgenSupport.getLabel();

		s.println("# Evaluate the operand");
		e1.code(mn, env, s);
		s.println();

		s.println("# Fetch the boolean value of the operand");
		CgenSupport.emitFetchBool(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();

		s.println("# Save the operand");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Get the 'true' value");
		CgenSupport.emitLoadImm(CgenSupport.ACC, CgenSupport.BOOL_TRUE, s);
		s.println();

		int nItems = mn.nItems;
		s.println("# If operand is true, branch to label" + returnFalseLabel);
		CgenSupport.emitBeq(CgenSupport.T1, CgenSupport.ACC, returnFalseLabel,
				s);
		s.println();

		s.println("# Return true branch");
		s.println("# Restore operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Return true");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
		CgenSupport.emitBranch(endLabel, s);
		s.println();

		mn.nItems = nItems;
		s.println("# Return False branch");
		CgenSupport.emitLabelDef(returnFalseLabel, s);
		s.println();

		s.println("# Restore operand");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();

		s.println("# Return False");
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
		s.println();

		s.println("# End of complement expression");
		CgenSupport.emitLabelDef(endLabel, s);
		s.println();
	}
}

/**
 * Defines AST constructor 'int_const'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class int_const extends Expression
{
	public AbstractSymbol token;

	/**
	 * Creates "int_const" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for token
	 */
	public int_const(int lineNumber, AbstractSymbol a1)
	{
		super(lineNumber);
		token = a1;
	}

	public TreeNode copy()
	{
		return new int_const(lineNumber, copy_AbstractSymbol(token));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "int_const\n");
		dump_AbstractSymbol(out, n + 2, token);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_int");
		dump_AbstractSymbol(out, n + 2, token);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method method is provided
	 * to you as an example of code generation.
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Integer constant");
		CgenSupport
				.emitLoadInt(CgenSupport.ACC,
						(IntSymbol) AbstractTable.inttable.lookup(token
								.getString()), s);
		s.println();
	}

}

/**
 * Defines AST constructor 'bool_const'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class bool_const extends Expression
{
	public Boolean val;

	/**
	 * Creates "bool_const" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for val
	 */
	public bool_const(int lineNumber, Boolean a1)
	{
		super(lineNumber);
		val = a1;
	}

	public TreeNode copy()
	{
		return new bool_const(lineNumber, copy_Boolean(val));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "bool_const\n");
		dump_Boolean(out, n + 2, val);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_bool");
		dump_Boolean(out, n + 2, val);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method method is provided
	 * to you as an example of code generation.
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Boolean constant");
		CgenSupport.emitLoadBool(CgenSupport.ACC, new BoolConst(val), s);
		s.println();
	}
}

/**
 * Defines AST constructor 'string_const'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class string_const extends Expression
{
	public AbstractSymbol token;

	/**
	 * Creates "string_const" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for token
	 */
	public string_const(int lineNumber, AbstractSymbol a1)
	{
		super(lineNumber);
		token = a1;
	}

	public TreeNode copy()
	{
		return new string_const(lineNumber, copy_AbstractSymbol(token));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "string_const\n");
		dump_AbstractSymbol(out, n + 2, token);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_string");
		out.print(Utilities.pad(n + 2) + "\"");
		Utilities.printEscapedString(out, token.getString());
		out.println("\"");
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method method is provided
	 * to you as an example of code generation.
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# String constant");
		CgenSupport.emitLoadString(CgenSupport.ACC,
				(StringSymbol) AbstractTable.stringtable.lookup(token
						.getString()), s);
		s.println();
	}
}

/**
 * Defines AST constructor 'new_'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class new_ extends Expression
{
	public AbstractSymbol type_name;

	/**
	 * Creates "new_" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for type_name
	 */
	public new_(int lineNumber, AbstractSymbol a1)
	{
		super(lineNumber);
		type_name = a1;
	}

	public TreeNode copy()
	{
		return new new_(lineNumber, copy_AbstractSymbol(type_name));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "new_\n");
		dump_AbstractSymbol(out, n + 2, type_name);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_new");
		dump_AbstractSymbol(out, n + 2, type_name);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Expression 'new'");
		s.println();
		if (type_name.equals(TreeConstants.SELF_TYPE))
		{
			s.println("# Get the class tag of the invoking object");
			CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
			s.println();

			s.println("# Get the address to the prototype object of self");
			s.println();
			s.println("# Offset in object table at which required prototype");
			s.println("# object is obtained");
			CgenSupport.emitSll(CgenSupport.ACC, CgenSupport.ACC, 3, s);

			s.println("# Base of the object table");
			CgenSupport.emitLoadAddress(CgenSupport.T1,
					CgenSupport.CLASSOBJTAB, s);

			s.println("# Address of the required prototype object");
			CgenSupport.emitAdd(CgenSupport.ACC, CgenSupport.T1,
					CgenSupport.ACC, s);

			s.println("# Save address. Will need it to calculate the");
			s.println("# reference to the init method");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);

			s.println("# Create new object");
			CgenSupport.emitPush(CgenSupport.FP, mn, s);
			CgenSupport.emitLoad(CgenSupport.ACC, 0, CgenSupport.ACC, s); // How??
																			// Incomplete
			CgenSupport.emitJal("Object.copy", s);
			CgenSupport.emitPop(CgenSupport.FP, mn, s);

			s.println("# Restore address of prototype object");
			CgenSupport.emitPop(CgenSupport.T1, mn, s);
			s.println("# Address of init method");
			// CgenSupport.emitAddiu(CgenSupport.T1, CgenSupport.T1, 4, s);
			CgenSupport.emitLoad(CgenSupport.T1, 1, CgenSupport.T1, s); // How??
																		// Incomplete

			CgenSupport.emitPush(CgenSupport.FP, mn, s);
			CgenSupport.emitJalr(CgenSupport.T1, s);
			CgenSupport.emitPop(CgenSupport.FP, mn, s);
		}
		else
		{
			s.println("# Create new object of type " + type_name);
			CgenSupport.emitCallObjectCopy(type_name, mn, s);
			s.println();
			// Attributes are initialized to default values or according to
			// their initializers by init call as this is a copy
			// of a prototype object
		}
		s.println("# End - Expression 'new'");
		s.println();
	}
}

/**
 * Defines AST constructor 'isvoid'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class isvoid extends Expression
{
	public Expression e1;

	/**
	 * Creates "isvoid" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for e1
	 */
	public isvoid(int lineNumber, Expression a1)
	{
		super(lineNumber);
		e1 = a1;
	}

	public TreeNode copy()
	{
		return new isvoid(lineNumber, (Expression) e1.copy());
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "isvoid\n");
		e1.dump(out, n + 2);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_isvoid");
		e1.dump_with_types(out, n + 2);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# isvoid expression");
		s.println();

		int falseLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();

		s.println("# Evaluate the operand and get reference in $a0");
		e1.code(mn, env, s);
		s.println();

		s.println("# Get the class tag of the object");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println();

		s.println(" #isvoid?? Branch to the 'false' branch if not void, label"
				+ falseLabel);
		CgenSupport.emitBgti(CgenSupport.ACC, CgenSupport.VOID_CLASSTAG,
				falseLabel, s);
		s.println();

		s.println("# True branch");
		s.println("# Return value is true");
		CgenSupport.emitLoadBool(CgenSupport.ACC, new BoolConst(true), s);
		CgenSupport.emitBranch(endLabel, s);
		s.println();

		s.println("# False branch");
		CgenSupport.emitLabelDef(falseLabel, s);

		s.println("# Return value is true");
		CgenSupport.emitLoadBool(CgenSupport.ACC, new BoolConst(false), s);
		s.println();

		s.println("# End of isvoid expression");
		CgenSupport.emitLabelDef(endLabel, s);
		CgenSupport.emitStoreBool(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();
	}
}

/**
 * Defines AST constructor 'no_expr'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class no_expr extends Expression
{
	/**
	 * Creates "no_expr" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 */
	public no_expr(int lineNumber)
	{
		super(lineNumber);
	}

	public TreeNode copy()
	{
		return new no_expr(lineNumber);
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "no_expr\n");
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_no_expr");
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
	}
}

/**
 * Defines AST constructor 'object'.
 * <p>
 * See <a href="TreeNode.html">TreeNode</a> for full documentation.
 */
class object extends Expression
{
	public AbstractSymbol name;

	/**
	 * Creates "object" AST node.
	 * 
	 * @@param lineNumber the line in the source file from which this node came.
	 * @@param a0 initial value for name
	 */
	public object(int lineNumber, AbstractSymbol a1)
	{
		super(lineNumber);
		name = a1;
	}

	public TreeNode copy()
	{
		return new object(lineNumber, copy_AbstractSymbol(name));
	}

	public void dump(PrintStream out, int n)
	{
		out.print(Utilities.pad(n) + "object\n");
		dump_AbstractSymbol(out, n + 2, name);
	}

	public void dump_with_types(PrintStream out, int n)
	{
		dump_line(out, n);
		out.println(Utilities.pad(n) + "_object");
		dump_AbstractSymbol(out, n + 2, name);
		dump_type(out, n);
	}

	/**
	 * Generates code for this expression.
	 * 
	 * @@param s the output stream
	 * */
	public void code(MethodNode mn, CgenClassTable env, PrintStream s)

	{
		s.println("# Expression - Object");
		s.println();
		if (name.toString().equals(TreeConstants.self.toString()))
		{
			s.println("# Invoking object is self");
		}
		else
		{
			if (env.lookup(name) != null)
			{
				s.println("# Identifier is local");
				CgenSupport.emitLoad(CgenSupport.ACC,
						(Integer) env.lookup(name), CgenSupport.FP, s);
			}
			else
			{// attribute
				s.println("# Identifier is an attribute");

				s.println("# Class tag of invoking object");
				CgenSupport.emitPush(CgenSupport.ACC, mn, s);
				CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC,
						s);

				int aLabel[] = new int[env.aTab.get(name).size()];
				int endLabel = CgenSupport.getLabel();
				int nLabel = 0;
				for (Iterator<AttrNode> i = env.aTab.get(name).iterator(); i
						.hasNext(); nLabel++)
				{
					AttrNode attrNd = i.next();
					aLabel[nLabel] = CgenSupport.getLabel();
					CgenSupport.emitLoadImm(CgenSupport.T1, attrNd.classTag, s);
					CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1,
							aLabel[nLabel], s);
				}
				int nItems = 0;
				nItems = mn.nItems;
				nLabel = 0;
				for (Iterator<AttrNode> i = env.aTab.get(name).iterator(); i
						.hasNext(); nLabel++)
				{

					mn.nItems = nItems;
					AttrNode attrNd = i.next();
					CgenSupport.emitLabelDef(aLabel[nLabel], s);
					CgenSupport.emitPop(CgenSupport.ACC, mn, s);
					CgenSupport.emitLoad(CgenSupport.ACC, attrNd.offset,
							CgenSupport.ACC, s);
					CgenSupport.emitBranch(endLabel, s);
				}
				CgenSupport.emitLabelDef(endLabel, s);
			}
		}
		s.println("# End - Expression - Object");
		s.println();
	}
}@


1.45
log
@58/63
@
text
@d991 1
a991 2
		Iterator<MethodNode> i;
		for (i = env.mTab.get(name).iterator(); i.hasNext();)
a1166 1
		//
a1174 1
		//
a1616 2
		// if (mn != null)
		// nItems = mn.nItems;
d1639 1
a1639 3
			// Incomplete
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);// using this pop as I am
													// aborting
a3382 1

@


1.44
log
@58/63
@
text
@d27 1
a27 1
	public abstract void cgen(PrintStream s) ;
d394 2
a395 3
			System.err
					.println("Compilation halted due to static semantic " +
							"errors.");
d407 1
a407 1
	public void cgen(PrintStream s) 
d769 1
a769 1
			
d825 2
a826 2
			if (mn.m != null)
				nItems = mn.nItems;
d831 2
a832 2
				if (mn.m != null)
					mn.nItems = nItems;
d934 1
a934 1
			
d974 1
a974 1
		if (mn.m != null)
d1006 3
a1008 3
		if (mn.m != null) // The arguments of this AR will be popped by the
							// callee
			mn.nItems -= actual.getLength();
d1014 1
a1014 2
		if (mn.m != null)
			mn.nItems = nItems - actual.getLength();
d1113 1
a1113 1
			
d1116 1
a1155 9
		
		// The execution may branch off if the invoking object is void
		// resulting in a totally different type of AR, say A1.
		int nItems = 0;
		if (mn.m != null)
		{
			// mn.m = null means that the dispatch expression is being invoked
			// from an init method. An init method obviously makes references
			// only to class attributes so it does not need mn.nItems.
d1157 9
a1165 2
			// Also invoking object cannot be void if dispatch is taking place from
			// init method
d1167 12
a1178 23
			s.println("# Need to check if the invoking object is void");
			s.println("# Fetch its classtag");
			CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
			s.println("# Get the classtag of void");
			CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG,
					s);
			s.println("# The test. Is the invoking object not void?");
			s.println("# If yes, branch to label" + notVoidLabel);
			CgenSupport.emitBne(CgenSupport.ACC, CgenSupport.T1, 
					notVoidLabel, s);
			s.println("# Else, invoking object is void.");

			nItems = mn.nItems;
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			CgenSupport.emitLoadString(CgenSupport.ACC,
					(StringSymbol) AbstractTable.stringtable
							.lookup(mn.nd.filename.toString()), s);
			CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
			CgenSupport.emitJal("_dispatch_abort", s);
			CgenSupport.emitPop(CgenSupport.FP, mn, s);
			mn.nItems = nItems;

		}
d1180 1
a1184 1

d1205 1
a1205 2
		if (mn.m != null)
			nItems = mn.nItems;
d1211 2
a1212 2
			if (mn.m != null)
				mn.nItems = nItems;
d1230 3
a1232 3
		if (mn.m != null) // The arguments of this AR will be popped by the
							// callee
			mn.nItems -= actual.getLength();
a1236 1

a1297 1
			
d1332 2
a1333 2
		if (mn.m != null)
			nItems = mn.nItems;
d1347 1
a1347 2
		if (mn.m != null)
			mn.nItems = nItems;
d1421 1
a1421 1
			
d1553 1
a1553 1
			
d1557 1
a1557 1
		
d1560 1
a1560 1
		
d1567 1
a1567 1
				
d1570 1
a1570 1
		
d1582 2
a1583 2
				(StringSymbol) AbstractTable.stringtable
						.lookup(mn.nd.filename.toString()), s);
d1585 3
a1587 3
		CgenSupport.emitJal("_case_abort2", s);	
		s.println();	
				
d1589 1
a1589 1
		
d1620 4
a1623 4
		//if (mn != null)
			//nItems = mn.nItems;
		for (Iterator<LinkedList<Integer>> i = env.caseTab.values().iterator();
				i.hasNext(); n++)
d1634 1
a1634 2
				for (Enumeration e = cases.getElements(); e.hasMoreElements(); 
						m++)
d1643 1
a1643 2
//			if (mn != null)
	//			mn.nItems = nItems;
d1645 3
a1647 2
			CgenSupport.emitPop(CgenSupport.ACC, s);// using this pop as I am aborting
			CgenSupport.emitPop(CgenSupport.ACC, s);
d1649 1
a1686 2
		
		
d1743 1
a1743 1
			
d1846 1
a1846 1
			
d1960 1
a1960 1
			
d2058 1
a2058 1
			
d2157 1
a2157 1
			
d2257 1
a2257 1
			
d2360 1
a2360 1
			
d2447 1
a2447 1
			
d2573 1
a2573 1
			
d2688 1
a2688 1
			
d2808 1
a2808 1
			
d2916 1
a2916 1
			
d2975 1
a2975 1
			
d3032 1
a3032 1
			
d3090 1
a3090 1
			
d3198 1
a3198 1
			
d3282 1
a3282 1
			
d3333 1
a3333 1
			
d3371 1
a3371 2
				if (mn.m != null)
					nItems = mn.nItems;
d3377 1
a3377 2
					if (mn.m != null)
						mn.nItems = nItems;
@


1.43
log
@58/63
@
text
@d1117 1
a1117 2
		int voidLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();
d1125 1
d1154 4
d1163 1
a1163 1
			// mn = null means that the dispatch expression is being invoked
d1167 1
a1167 1
			// invoking object cannot be void if dispatch is taking place from
d1169 1
a1170 2
			s.println("# Save the invoking object");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
a1171 2
			nItems = mn.nItems; // If the invoking method is void, we could have
								// a different AR
d1176 5
d1182 1
a1182 5
			s.println("# The test. Is the invoking object void?");
			s.println("# If yes, branch to label" + voidLabel);
			CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, voidLabel, s);
			s.println("# Else, invoking object is not void.");
			s.println("# Restore the invoking object");
d1184 8
a1191 1
			s.println();
d1194 5
a1250 15
		CgenSupport.emitBranch(endLabel, s);

		if (mn.m != null)// Restore the number of AR entries
		{
			mn.nItems = nItems - actual.getLength();
			CgenSupport.emitLabelDef(voidLabel, s);
			CgenSupport.emitPop(CgenSupport.ACC, mn, s);
			CgenSupport.emitLoadString(CgenSupport.ACC,
					(StringSymbol) AbstractTable.stringtable
							.lookup(mn.nd.filename.toString()), s);
			CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
			CgenSupport.emitJal("_dispatch_abort", s);
			CgenSupport.emitPop(CgenSupport.FP, mn, s);
		}
		CgenSupport.emitLabelDef(endLabel, s);
@


1.42
log
@58/63
@
text
@d27 1
a27 1
	public abstract void cgen(PrintStream s) throws AddressNotFoundException;
d234 1
a234 2
	public abstract void code(MethodNode mn, CgenClassTable env, PrintStream s)
			throws AddressNotFoundException;
d395 2
a396 1
					.println("Compilation halted due to static semantic errors.");
d408 1
a408 1
	public void cgen(PrintStream s) throws AddressNotFoundException
d725 2
a726 2
	public AbstractSymbol name;
	public Expression expr;
d765 1
a765 3
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
d770 1
a770 1
			throws AddressNotFoundException
d772 1
a772 1
		s.println("# assign expression");
d935 1
a935 1
			throws AddressNotFoundException
d1115 1
a1115 1
			throws AddressNotFoundException
d1315 1
a1315 1
			throws AddressNotFoundException
d1440 1
a1440 1
			throws AddressNotFoundException
d1572 1
a1572 1
			throws AddressNotFoundException
d1577 3
d1582 1
a1583 1
		s.println("# Case expression");
d1588 2
d1764 1
a1764 1
			throws AddressNotFoundException
d1867 1
a1867 1
			throws AddressNotFoundException
d1981 1
a1981 1
			throws AddressNotFoundException
d2079 1
a2079 1
			throws AddressNotFoundException
d2178 1
a2178 1
			throws AddressNotFoundException
d2278 1
a2278 1
			throws AddressNotFoundException
d2381 1
a2381 1
			throws AddressNotFoundException
d2468 1
a2468 1
			throws AddressNotFoundException
d2594 1
a2594 1
			throws AddressNotFoundException
d2709 1
a2709 1
			throws AddressNotFoundException
d2829 1
a2829 1
			throws AddressNotFoundException
d2937 1
a2937 1
			throws AddressNotFoundException
d2996 1
a2996 1
			throws AddressNotFoundException
d3053 1
a3053 1
			throws AddressNotFoundException
d3111 1
a3111 1
			throws AddressNotFoundException
d3219 1
a3219 1
			throws AddressNotFoundException
d3303 1
a3303 1
			throws AddressNotFoundException
d3354 1
a3354 1
			throws AddressNotFoundException
a3408 1

a3409 6
			/*
			 * offsetAddress a = Utilities.getAddress(name, mn.nd, env);
			 * s.println("# Get the object address");
			 * CgenSupport.emitLoad(CgenSupport.ACC, a.offset, a.reg, s);
			 * s.println();
			 */
@


1.41
log
@57/63
@
text
@d2708 1
a2708 1
		s.println("# < expression");
@


1.40
log
@56/63
@
text
@d1576 1
d1579 1
a1579 1
		s.println("# Save self. Needed while evaluating the branch");
a1585 2
		
		// void
d1603 2
d1606 1
a1606 5
		
		
		
		CgenSupport.emitLabelDef(notVoidLabel, s);
		s.println("# Restore the evaluted expression");
a1610 1
		
d1616 1
a1616 1
		// Once this is obtained, we can generate code to find out
d1636 4
a1639 2
		for (Iterator<LinkedList<Integer>> i = env.caseTab.values().iterator(); i
				.hasNext(); n++)
d1650 2
a1651 1
				for (Enumeration e = cases.getElements(); e.hasMoreElements(); m++)
d1660 6
a1666 2
		// Incomplete
		// CgenSupport.emitAbort();
a1670 1
		int nItems = 0;
d1703 2
@


1.39
log
@55/63
@
text
@d784 1
a784 1
		
d791 1
a791 1
			
d826 1
a826 1
			
d840 1
a840 1
				CgenSupport.emitStore(CgenSupport.T1, attrNd.offset, 
a848 6
	
		/*offsetAddress a = Utilities.getAddress(name, mn.nd, env);

		s.println("# Store the result in the location of the variable");
		CgenSupport.emitStore(CgenSupport.T1, a.offset, a.reg, s);
		s.println();
d850 10
a859 3
		s.println("# De-cache the result. It must be in $a0");
		CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);
		*/
d1510 1
a1510 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d1576 2
d1580 1
a1580 1
		
d1584 20
d1605 6
d1617 2
a1618 2
		
		// Code to jump to a particular branch of execution based on the  
d1624 1
a1624 2
		for (Iterator<Integer> i = env.caseTab.keySet().iterator(); 
				i.hasNext(); n++)
d1629 2
a1630 2
			CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, 
					typeLabel[n], s);
d1633 2
a1634 2
		// CgenSupport.emitAbort(); 
		
d1640 2
a1641 2
		for(Iterator<LinkedList<Integer>> i = env.caseTab.values().iterator(); 
				i.hasNext(); n++)
d1644 1
a1644 1
			
d1646 2
a1647 2
			
			for (Iterator<Integer> k = lst.iterator(); k.hasNext(); )
d1652 1
a1652 2
				for (Enumeration e = cases.getElements(); e.hasMoreElements();
						m++)
d1654 3
a1656 3
					branch b = (branch)e.nextElement();
					CgenSupport.emitLoadImm(CgenSupport.T1, 
							((CgenNode)env.lookup(b.type_decl)).classTag, s);
d1664 1
a1664 1
		
d1671 1
a1671 2
		for (Enumeration e = cases.getElements(); e.hasMoreElements();
				n++)
d1673 2
a1674 2
			branch b = (branch)e.nextElement();
			
d1682 1
a1682 1
			
d1685 1
a1685 1
			
d1688 2
a1689 1
			// The offset is negative as the location of local variables are below
d1692 1
a1692 1
			
d1694 1
a1694 1
			
d3366 1
a3366 1
				
d3391 1
a3391 1
					
@


1.38
log
@55/63
@
text
@d1641 3
d1651 2
a1652 1
			
@


1.37
log
@51/63
@
text
@d1575 3
d1589 2
a1590 2
		// Code to jump to a branch of execution which finds the LUB from among 
		// types of the case-branches
d1617 1
a1617 1
			LinkedList<Integer>  lst = i.next();
d1648 1
d1650 4
d1655 3
a1657 2
			s.println("# Save the let variable in the stack");
			CgenSupport.emitPush(CgenSupport.ACC, mn, s);
d1664 1
@


1.36
log
@49/63
@
text
@d1575 86
@


1.35
log
@44/63
@
text
@d807 1
a807 1
			s.println("# Save the result");
d826 1
d841 3
a843 1
						CgenSupport.ACC, s);	
d1469 1
d1475 1
d1509 1
a1509 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC,
a1574 1

@


1.34
log
@43/63
@
text
@d826 3
d833 2
@


1.33
log
@43/63
@
text
@d3248 3
d3255 3
@


1.32
log
@47/63
@
text
@d784 25
d810 3
a812 3
		s.println("# Temporarily cache the result");
		CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
		s.println();
d814 25
a838 5
		s.println("# Restore the self object");
		s.println("# Self object is needed as the subsequent store ");
		s.println("#    might be w.r.t to the self object");
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		s.println();
d840 3
a842 1
		offsetAddress a = Utilities.getAddress(name, mn.nd, env);
d850 1
d932 1
a932 1
		
d970 5
a974 4
		s.println("# Test if invoking object is void");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG, s);
d976 2
a977 2
		CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, voidLabel, s);
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
d979 1
a979 1
		
d1000 2
a1001 1
		if (mn.m != null) // The arguments of this AR will be popped by the callee
d1011 8
a1018 8
		CgenSupport.emitLabelDef(voidLabel, s);
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		CgenSupport.emitLoadString(CgenSupport.ACC,
				(StringSymbol) AbstractTable.stringtable.lookup(mn.nd.filename
						.toString()), s);
		CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
		CgenSupport.emitJal("_dispatch_abort", s);
		CgenSupport.emitPop(CgenSupport.FP, mn, s);
d1151 4
a1154 4
		{ 
			// mn = null means that the dispatch expression is being invoked 
			// from an init method. An init method obviously makes references 
			// only to class attributes so it does not need mn.nItems. 
d1162 2
a1163 1
			nItems = mn.nItems; // If the invoking method is void, we could have a different AR
d1178 2
a1179 2
		s.println("# Determine the dispatch based on the " +
				"type of the self object");
d1187 2
a1188 2
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator();
				i.hasNext(); k++)
d1224 2
a1225 1
		if (mn.m != null) // The arguments of this AR will be popped by the callee
d2979 1
a2979 1
			s.println();			
d2982 1
a2982 1
			CgenSupport.emitSll(CgenSupport.ACC, CgenSupport.ACC,3 , s);
d2991 1
a2991 1
			
d2995 1
a2995 1
			
d2998 2
a2999 1
			CgenSupport.emitLoad(CgenSupport.ACC, 0, CgenSupport.ACC, s); // How?? Incomplete
d3002 1
a3002 1
			
d3006 4
a3009 3
			//CgenSupport.emitAddiu(CgenSupport.T1, CgenSupport.T1, 4, s);
			CgenSupport.emitLoad(CgenSupport.T1, 1, CgenSupport.T1, s); // How?? Incomplete
			
d3212 1
a3212 3
	{// The SymbolTable will contain <name, offset> pairs. 'offset is with
		// respect to the FP

d3221 9
a3229 1
			offsetAddress a = Utilities.getAddress(name, mn.nd, env);
d3231 37
a3267 4

			s.println("# Get the object address");
			CgenSupport.emitLoad(CgenSupport.ACC, a.offset, a.reg, s);
			s.println();
d3271 1
@


1.31
log
@44/63
@
text
@d920 1
a920 1
		if (mn != null)
d951 1
a951 1
		if (mn != null) // The arguments of this AR will be popped by the callee
d958 1
a958 1
		if (mn != null)
d1100 1
a1100 1
		if (mn != null)
d1147 1
a1147 1
		if (mn != null)
d1154 1
a1154 1
			if (mn != null)
d1173 1
a1173 1
		if (mn != null) // The arguments of this AR will be popped by the callee
d1180 1
a1180 1
		if (mn != null)// Restore the number of AR entries
d1291 1
a1291 1
		if (mn != null)
d1306 1
a1306 1
		if (mn != null)
d3170 1
@


1.30
log
@41/63
@
text
@d2922 1
a2922 1
			// Get the class tag of the invoking object
d2924 1
d2926 5
a2930 3
			// Multiplier for the class tag. The reference to the prototype
			// objects are aligned at double word boundaries
			CgenSupport.emitLoadImm(CgenSupport.T1, 8, s);
d2932 1
a2932 6
			// Offset in object table at which required prototype object is
			// obtained
			CgenSupport.emitMul(CgenSupport.ACC, CgenSupport.ACC,
					CgenSupport.T1, s);

			// Base of the object table
d2936 1
a2936 1
			// Address of the required prototype object in ACC
d2939 20
a2958 3

			CgenSupport.emitCallObjectCopy(mn, s);

@


1.29
log
@40/63
@
text
@d27 1
a27 1
	public abstract void cgen(PrintStream s)  throws AddressNotFoundException;
d234 2
a235 1
	public abstract void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException;
d408 1
a408 1
	public void cgen(PrintStream s)  throws AddressNotFoundException
d771 2
a772 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d776 1
a776 1
		
d780 1
a780 1
		
d784 1
a784 1
		
d788 1
a788 1
		
d794 1
a794 1
		
d796 1
a796 1
		
d800 1
a800 1
		
d803 1
a803 1
		
d879 2
a880 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d882 3
d886 1
a886 1
		
d890 1
a890 1
		
d905 1
a905 1
			
d909 1
a909 1
			
d918 4
a921 1
		
a922 2
		int voidLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();
a925 2
		int nItems = 0;
		if (mn != null)
d928 2
a930 1
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
d933 2
a934 7
		
		CgenNode nd = (CgenNode)(env.lookup(type_name));
		/*if (type_name.equals(TreeConstants.SELF_TYPE))
				nd = mn.nd;
				*/
		
		
d936 2
a937 2
		for(Iterator<MethodNode> i = env.mTab.get(name).iterator(); 
				i.hasNext(); )
d940 1
a940 1
			if (m1.nd.name.equals(nd))
d943 1
a943 3
		
		
		
d946 1
a946 1
		
d957 1
a957 1
		
d960 1
d963 3
a965 2
		CgenSupport.emitLoadString(CgenSupport.ACC, 
				(StringSymbol)AbstractTable.stringtable.lookup(mn.nd.filename.toString()), s);
d969 2
a970 1
		
a1032 1

d1036 1
a1036 1
		
d1038 1
a1038 1
		
d1044 2
a1045 2
			for(Enumeration e = nd.getChildren(); e.hasMoreElements(); )
				q.add((CgenNode)e.nextElement());
d1049 1
d1057 2
a1058 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1060 3
d1064 1
a1064 1
		
d1068 1
a1068 1
		
d1083 1
a1083 1
			
d1087 1
a1087 1
			
d1096 3
a1098 13
		
		s.println("# Need to check if the invoking object is void");
		int voidLabel = CgenSupport.getLabel();
		int endLabel = CgenSupport.getLabel();
		s.println("# Save the invoking object");
		CgenSupport.emitPush(CgenSupport.ACC, mn, s);
		s.println("# Fetch its classtag");
		CgenSupport.emitFetchClassTag(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println("# Get the classtag of void");
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.VOID_CLASSTAG, s);
		
		// The execution may now branch off. Thus save the count of the number
		// of records in the current AR
d1100 25
a1124 8
		if (mn != null) { // invoking object cannot be void if calling from init method
			nItems = mn.nItems;
		
		s.println("# The test. Is the invoking object void?");
		s.println("# If yes, branch to label" + voidLabel);
		CgenSupport.emitBeq(CgenSupport.ACC, CgenSupport.T1, voidLabel, s);
		s.println("# Else, invoking object is not void.");
		s.println("# Restore the invoking object");
d1126 3
a1128 1
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
a1129 4
		
		s.println("# Determine the dispatch based on the type of the self object");
		s.println();
		
d1136 1
a1136 1
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator(); 
d1146 1
a1146 1
		
d1151 2
a1152 2
		for (Iterator<MethodNode> i = env.mTab.get(name).iterator(); 
				i.hasNext(); j++)
d1168 1
a1168 2
		
		
d1172 2
a1173 2
		
		if (mn!=null) // The arguments of this AR will be popped by the callee
d1179 1
a1179 1
		
d1181 10
a1190 8
		{	mn.nItems = nItems - actual.getLength();
		CgenSupport.emitLabelDef(voidLabel, s);
		CgenSupport.emitPop(CgenSupport.ACC, mn, s);
		CgenSupport.emitLoadString(CgenSupport.ACC, 
				(StringSymbol)AbstractTable.stringtable.lookup(mn.nd.filename.toString()), s);
		CgenSupport.emitLoadImm(CgenSupport.T1, 1, s);
		CgenSupport.emitJal("_dispatch_abort", s);
		CgenSupport.emitPop(CgenSupport.FP, mn, s);
d1255 2
a1256 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1263 1
a1263 1
		
d1268 1
a1268 1
		
d1272 1
a1272 1
		
d1275 1
a1275 1
		
d1286 1
a1286 1
		
d1289 1
a1289 1
		//   branch
d1297 1
a1297 1
		
d1301 1
a1301 1
		
d1311 1
a1311 1
		
d1315 1
a1315 1
		
d1380 2
a1381 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1388 1
a1388 1
		
d1401 1
a1401 1
		
d1410 1
a1410 1
		
d1415 1
a1415 1
		
d1420 1
a1420 1
		
d1424 1
a1424 1
		
d1433 2
a1434 2
		
		s.println("# Go back to label" + loopLabel 
d1510 2
a1511 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1568 3
a1570 2
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
	{		
d1577 1
a1577 1
			
d1581 1
a1581 1
			s.println("# Save self object before evaluating this expression."); 
d1586 2
a1587 2
			s.println("# Evaluate the expression and " +
					"get the reference in $a0");
d1590 3
a1592 3
			
			s.println("# Retrieve self object before evaluating the next " +
					"expression");
d1596 2
a1597 2
		s.println("# Evaluate the last expression and " +
				"get the reference in $a0");
d1600 1
a1600 1
		
d1671 2
a1672 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1679 3
a1681 3
		
		s.println("# Save the self object before evaluating the " +
				"initializer.");
d1687 1
a1687 1
		if (init.getClass().toString().equals("class no_expr"))	
d1689 3
a1691 3
			s.println("# No Initializer. Get the reference to the default " +
					"value in $a0 ");
			CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d1696 3
a1698 3
		{	
			s.println("# Evaluate the initializer and get the reference in " +
					"$a0");
d1700 1
a1700 1
			s.println();	
d1702 1
a1702 1
		
d1706 1
a1706 1
		
d1710 1
a1710 1
		
d1713 2
a1714 2
		//The offset is negative as the location of local variables are below 
		//the FP
d1717 1
a1717 2
		
		
d1721 1
a1721 1
		
d1726 1
a1726 1
		
d1785 2
a1786 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1790 1
a1790 1
		
d1797 1
a1797 1
		
d1800 1
a1800 1
		
d1806 1
a1806 1
				
d1815 1
a1815 1
		
d1817 2
a1818 2
		CgenSupport.emitAdd(CgenSupport.ACC, CgenSupport.T1, 
				CgenSupport.ACC, s);
d1883 2
a1884 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1888 1
a1888 1
		
d1895 1
a1895 1
		
d1898 1
a1898 1
		
d1904 1
a1904 1
				
d1913 1
a1913 1
		
d1915 2
a1916 2
		CgenSupport.emitSub(CgenSupport.ACC, CgenSupport.T1, 
				CgenSupport.ACC, s);
d1982 2
a1983 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1987 1
a1987 1
		
d1994 1
a1994 1
		
d1997 1
a1997 1
		
d2003 1
a2003 1
				
d2012 1
a2012 1
		
d2014 2
a2015 2
		CgenSupport.emitMul(CgenSupport.ACC, CgenSupport.T1, 
				CgenSupport.ACC, s);
d2082 2
a2083 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2087 1
a2087 1
		
d2096 1
a2096 1
		
d2100 1
a2100 1
		
d2108 1
a2108 1
				
d2120 1
a2120 1
		
d2122 2
a2123 2
		CgenSupport.emitDiv(CgenSupport.ACC, CgenSupport.T1, 
				CgenSupport.ACC, s);
d2185 2
a2186 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2190 1
a2190 1
		
d2194 1
a2194 1
				
d2200 1
a2200 1
		
d2204 1
a2204 1
		
d2208 1
a2208 1
		
d2212 1
a2212 1
		
d2272 2
a2273 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2280 2
a2281 2
		s.println("# Save self object. Needed during evaluation of the 2nd " +
				"operand");
d2284 1
a2284 1
		
d2288 1
a2288 1
		
d2292 3
a2294 3
		
		s.println("# Restore self object before evaluation of the 2nd " +
				"operand");
d2301 1
a2301 1
		
d2305 1
a2305 1
		
d2313 1
a2313 1
		
d2321 1
a2321 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2324 1
a2324 1
		
d2332 1
a2332 1
		
d2334 1
a2334 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2337 1
a2337 1
		
d2398 2
a2399 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2403 1
a2403 1
		
d2405 1
a2405 1
		
d2410 1
a2410 1
		
d2414 1
a2414 1
		
d2417 1
a2417 1
		
d2421 1
a2421 1
		
d2425 1
a2425 1
				
d2429 1
a2429 1
		
d2433 1
a2433 1
		
d2437 2
a2438 2
		s.println("# Are both operands the same object?. If yes go to label" +
				trueLabel);
d2441 1
a2441 1
		
d2443 1
a2443 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2445 1
a2445 1
		CgenSupport.emitLoadAddress(CgenSupport.A1, 
d2449 1
a2449 1
		
d2452 1
a2452 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2454 1
a2454 1
		
d2513 2
a2514 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2521 2
a2522 2
		s.println("# Save self object. Needed during evaluation of the 2nd " +
				"operand");
d2525 1
a2525 1
		
d2529 1
a2529 1
		
d2533 3
a2535 3
		
		s.println("# Restore self object before evaluation of the 2nd " +
				"operand");
d2542 1
a2542 1
		
d2546 1
a2546 1
		
d2554 1
a2554 1
		
d2562 1
a2562 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2565 1
a2565 1
		
d2573 1
a2573 1
		
d2575 1
a2575 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, 
d2578 1
a2578 1
		
d2581 2
a2582 1
		s.println();	}
d2633 2
a2634 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2638 1
a2638 1
		
d2645 1
a2645 1
		
d2653 1
a2653 1
		
d2660 2
a2661 1
		CgenSupport.emitBeq(CgenSupport.T1, CgenSupport.ACC, returnFalseLabel, s);
d2668 1
a2668 1
		
d2670 2
a2671 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
d2679 1
a2679 1
		
d2683 1
a2683 1
		
d2685 2
a2686 1
		CgenSupport.emitLoadAddress(CgenSupport.ACC, CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_TRUE, s);
d2688 1
a2688 1
		
d2741 2
a2742 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2800 2
a2801 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2857 2
a2858 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2915 2
a2916 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2941 1
a2941 1
			
d2950 1
a2950 1
			// Attributes are initialized to default values or according to 
d3006 2
a3007 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d3011 1
a3011 1
		
d3023 2
a3024 2
		s.println(" #isvoid?? Branch to the 'false' branch if not void, label" 
				+ falseLabel); 
d3037 1
a3037 1
		
d3090 3
a3092 2
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
	{		
d3138 1
d3141 2
a3142 1
	public void code(MethodNode mn, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d3155 1
a3155 1
			
@


1.28
log
@40/63
@
text
@d10 1
d234 1
a234 1
	public abstract void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException;
a513 2
	public int nItems;
	public int methodOffset;
a531 1
		nItems = 0;
d770 1
a770 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d776 1
a776 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d780 1
a780 1
		expr.code(c, m, env, s);
d790 1
a790 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d793 1
a793 1
		offsetAddress a = Utilities.getAddress(name, c, env);
d877 1
a877 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d882 1
a882 1
		CgenSupport.emitPush(CgenSupport.FP, m, s);
d888 1
a888 1
			CgenSupport.emitPush(CgenSupport.ACC, m, s);
d893 1
a893 1
			ex.code(c, m, env, s);
d901 1
a901 1
			CgenSupport.emitPop(CgenSupport.ACC, m, s);
d905 1
a905 1
			CgenSupport.emitPush(CgenSupport.T1, m, s);
d910 1
a910 1
		expr.code(c, m, env, s);
d916 1
a916 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d920 2
a921 2
		if (m != null)
			nItems = m.nItems;
d924 1
a924 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d929 17
a945 4
		if (type_name.equals(TreeConstants.SELF_TYPE))
				nd = c;
		CgenSupport.emitLoad(CgenSupport.T1, Utilities.getMethodOffset(nd, name),
				CgenSupport.T1, s);
d952 2
a953 2
		if (m!=null) // The arguments of this AR will be popped by the callee
			m.nItems -= actual.getLength();
d955 1
a955 1
		CgenSupport.emitPop(CgenSupport.FP, m, s);
d959 2
a960 2
		if (m != null)
			m.nItems = nItems - actual.getLength();
d962 1
a962 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d964 1
a964 1
				(StringSymbol)AbstractTable.stringtable.lookup(c.filename.toString()), s);
d967 1
a967 1
		CgenSupport.emitPop(CgenSupport.FP, m, s);
d1055 1
a1055 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1060 1
a1060 1
		CgenSupport.emitPush(CgenSupport.FP, m, s);
d1066 1
a1066 1
			CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1071 1
a1071 1
			ex.code(c, m, env, s);
d1079 1
a1079 1
			CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1083 1
a1083 1
			CgenSupport.emitPush(CgenSupport.T1, m, s);
d1088 1
a1088 1
		expr.code(c, m, env, s);
d1091 1
d1094 3
a1096 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1098 1
d1100 3
d1104 5
a1108 2
		if (m != null)
			nItems = m.nItems;
d1110 5
d1116 18
a1133 9
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
		s.println("# Get reference to dispatch method");
		CgenSupport.emitFetchDispTab(CgenSupport.T1, CgenSupport.ACC, s);

		CgenNode nd = (CgenNode)(env.lookup(expr.get_type()));
		if (expr.get_type().equals(TreeConstants.SELF_TYPE))
				nd = c;
		CgenSupport.emitLoad(CgenSupport.T1, Utilities.getMethodOffset(nd, name),
				CgenSupport.T1, s);
d1136 23
d1163 2
a1164 2
		if (m!=null) // The arguments of this AR will be popped by the callee
			m.nItems -= actual.getLength();
d1166 1
a1166 1
		CgenSupport.emitPop(CgenSupport.FP, m, s);
d1170 2
a1171 2
		if (m != null)// Restore the number of AR entries
			m.nItems = nItems - actual.getLength();
d1173 1
a1173 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1175 1
a1175 1
				(StringSymbol)AbstractTable.stringtable.lookup(c.filename.toString()), s);
d1178 2
a1179 2
		CgenSupport.emitPop(CgenSupport.FP, m, s);
		
d1243 1
a1243 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1253 1
a1253 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1257 1
a1257 1
		pred.code(c, m, env, s);
d1278 2
a1279 2
		if (m != null)
			nItems = m.nItems;
d1282 1
a1282 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1286 1
a1286 1
		then_exp.code(c, m, env, s);
d1293 2
a1294 2
		if (m != null)
			m.nItems = nItems;
d1300 1
a1300 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1304 1
a1304 1
		else_exp.code(c, m, env, s);
d1367 1
a1367 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1377 1
a1377 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1385 1
a1385 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1390 1
a1390 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1394 1
a1394 1
		pred.code(c, m, env, s);
d1408 1
a1408 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1413 1
a1413 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1417 1
a1417 1
		body.code(c, m, env, s);
d1429 1
a1429 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1496 1
a1496 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1553 1
a1553 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1567 1
a1567 1
			CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1572 1
a1572 1
			((Expression) (e.nextElement())).code(c, m, env, s);
d1577 1
a1577 1
			CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1582 1
a1582 1
		((Expression) (e.nextElement())).code(c, m, env, s);
d1655 1
a1655 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1666 1
a1666 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1682 1
a1682 1
			init.code(c, m, env, s);
d1691 1
a1691 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1695 1
a1695 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d1698 1
a1698 1
		env.addId(identifier, -(m.nItems - 1));
d1703 1
a1703 1
		body.code(c, m, env, s);
d1707 1
a1707 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1769 1
a1769 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1776 1
a1776 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1779 1
a1779 1
		e1.code(c, m, env, s);
d1785 1
a1785 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1788 1
a1788 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d1791 1
a1791 1
		e2.code(c, m, env, s);
d1797 1
a1797 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1802 1
a1802 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1805 1
a1805 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, m, s);
d1808 1
a1808 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1866 1
a1866 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1873 1
a1873 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1876 1
a1876 1
		e1.code(c, m, env, s);
d1882 1
a1882 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1885 1
a1885 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d1888 1
a1888 1
		e2.code(c, m, env, s);
d1894 1
a1894 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1899 1
a1899 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1902 1
a1902 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, m, s);
d1905 1
a1905 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1964 1
a1964 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d1971 1
a1971 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d1974 1
a1974 1
		e1.code(c, m, env, s);
d1980 1
a1980 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d1983 1
a1983 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d1986 1
a1986 1
		e2.code(c, m, env, s);
d1992 1
a1992 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d1997 1
a1997 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2000 1
a2000 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, m, s);
d2003 1
a2003 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2063 1
a2063 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2070 1
a2070 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2074 1
a2074 1
		e1.code(c, m, env, s);
d2082 1
a2082 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2086 1
a2086 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d2090 1
a2090 1
		e2.code(c, m, env, s);
d2098 1
a2098 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2104 1
a2104 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2108 1
a2108 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, m, s);
d2112 1
a2112 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2165 1
a2165 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2171 1
a2171 1
		e1.code(c, m, env, s);
d2177 1
a2177 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2181 1
a2181 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, m, s);
d2185 1
a2185 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2251 1
a2251 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2260 1
a2260 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2264 1
a2264 1
		e1.code(c, m, env, s);
d2273 1
a2273 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2277 1
a2277 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d2281 1
a2281 1
		e2.code(c, m, env, s);
d2289 1
a2289 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2376 1
a2376 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2385 1
a2385 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2389 1
a2389 1
		e1.code(c, m, env, s);
d2396 1
a2396 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2400 1
a2400 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d2404 1
a2404 1
		e2.code(c, m, env, s);
d2412 1
a2412 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2490 1
a2490 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2499 1
a2499 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2503 1
a2503 1
		e1.code(c, m, env, s);
d2512 1
a2512 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2516 1
a2516 1
		CgenSupport.emitPush(CgenSupport.T1, m, s);
d2520 1
a2520 1
		e2.code(c, m, env, s);
d2528 1
a2528 1
		CgenSupport.emitPop(CgenSupport.T1, m, s);
d2608 1
a2608 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2617 1
a2617 1
		e1.code(c, m, env, s);
d2625 1
a2625 1
		CgenSupport.emitPush(CgenSupport.ACC, m, s);
d2632 1
a2632 1
		int nItems = m.nItems;
d2639 1
a2639 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2647 1
a2647 1
		m.nItems = nItems;
d2653 1
a2653 1
		CgenSupport.emitPop(CgenSupport.ACC, m, s);
d2712 1
a2712 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2770 1
a2770 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2826 1
a2826 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2883 1
a2883 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2909 1
a2909 1
			CgenSupport.emitCallObjectCopy(m, s);
d2915 1
a2915 1
			CgenSupport.emitCallObjectCopy(type_name, m, s);
d2973 1
a2973 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d2982 1
a2982 1
		e1.code(c, m, env, s);
d3056 1
a3056 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d3105 1
a3105 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s) throws AddressNotFoundException
d3117 1
a3117 1
			offsetAddress a = Utilities.getAddress(name, c, env);
@


1.27
log
@40/63
@
text
@d940 3
a942 1
		
d949 1
a949 1
			m.nItems = nItems;
d1112 2
a1113 2
		if (m != null)
			m.nItems = nItems -actual.getLength();
@


1.26
log
@35/63
@
text
@d1103 2
d1111 1
a1111 1
			m.nItems = nItems;
a1120 1

d3053 1
a3053 1
			s.println("# Invoking object is the same as self");
@


1.25
log
@33/63
@
text
@d921 3
d946 2
d1083 3
d1108 2
@


1.24
log
@32/64
@
text
@d881 1
a881 1
		s.println("# Method dispatch\n");
d915 9
a924 2
		//CgenSupport.emitFetchDispTab(CgenSupport.T1, 
			//	type_name.toString() + CgenSupport.DISPTAB_SUFFIX, s);
d941 11
d1073 8
d1097 13
a1109 1
		s.println();		
@


1.23
log
@31/63
@
text
@d916 3
a918 2
		CgenSupport.emitFetchDispTab(CgenSupport.T1, 
				type_name.toString() + CgenSupport.DISPTAB_SUFFIX, s);
a2798 3

			// Initialise attributes of the object with default values
			// Incomplete
@


1.22
log
@30/63
@
text
@a2778 2
			System.out.println("Incomplete. new SELF_TYPE not implemented");
			// Incomplete
a2798 9
			// Address of the init method of the prototype object
			CgenSupport.emitAddiu(CgenSupport.T1, CgenSupport.ACC, 4, s);

			// Create a new object
			CgenSupport.emitPush(CgenSupport.FP, m, s);
			CgenSupport.emitJal("Object.copy", s);
			CgenSupport.emitJalr(CgenSupport.T1, s);
			CgenSupport.emitPop(CgenSupport.FP, m, s);

d2801 2
d2810 3
a2812 104
			

			s.println("# Initialise attributes of the object with default values");
			// Incomplete : What if there are inherited fields???
			int offset = CgenSupport.DEFAULT_OBJFIELDS;
			for (Enumeration e = ((CgenNode) (env.lookup(type_name)))
					.getFeatures().getElements(); e.hasMoreElements();)
			{
				try
				{
					attr a = (attr) e.nextElement();
					if (a.type_decl.equals(TreeConstants.Str)
							|| a.type_decl.equals(TreeConstants.Bool)
							|| a.type_decl.equals(TreeConstants.Int))
					{
						s.println("# Save the new object");
						CgenSupport.emitPush(CgenSupport.ACC, m, s);
						s.println();

						s.println("# Create a new object representing the default type of the attribute "
								+ (offset - CgenSupport.DEFAULT_OBJFIELDS + 1)
								+ ", i.e. " + a.name);
						s.println("# A call to object.copy does this as prototype objects represent default values");
						CgenSupport.emitCallObjectCopy(a.type_decl, m, s);
						s.println();
						s.println("# Temporarily cache it in $t1");
						CgenSupport
								.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
						s.println();

						s.println("# Restore reference to the new object as it must be the self object to initialize the new attribute");
						CgenSupport.emitPop(CgenSupport.ACC, m, s);
						s.println();

						s.println("# Store the default initilized attribute in the new object");
						CgenSupport.emitStore(CgenSupport.T1, offset,
								CgenSupport.ACC, s);
						s.println();
					}
					else
					{
						s.println("# Initialise attribute " 
								+ (offset - CgenSupport.DEFAULT_OBJFIELDS + 1) 
								+ "of new object with void");
						CgenSupport.emitLoadAddress(CgenSupport.T1,
								CgenSupport.VOIDCONST_PREFIX, s);
						CgenSupport.emitStore(CgenSupport.T1, offset,
								CgenSupport.ACC, s);
					}
					offset++;
				}
				catch (ClassCastException ex)
				{
					continue;
				}
			}

			s.println("# Initialise attributes of the object with initializers");
			s.println("# Note that the new object is in $a0 and thus acts as the self object");
			offset = CgenSupport.DEFAULT_OBJFIELDS;
			for (Enumeration e = ((CgenNode) (env.lookup(type_name)))
					.getFeatures().getElements(); e.hasMoreElements();)
			{
				try
				{
					attr a = (attr) e.nextElement();
					if (a.init.getClass().toString().equals("class no_expr"))
					{
						s.println("# Attribute, " + a.name + ", has no initializer");
						s.println();
					}
					else
					{
						s.println("# Save reference to the new object.");
						s.println("# Will need it while evaluating initializers of other attributes");
						CgenSupport.emitPush(CgenSupport.ACC, m, s);
						s.println();

						s.println("# Evaluate the initializer and get reference in $a0");
						// initializer code of attributes are in class 'type_name'
						a.init.code((CgenNode)env.lookup(type_name), m, env, s);
						s.println();

						s.println("# Temporarily cache the initializer in $t1");
						CgenSupport
								.emitMove(CgenSupport.T1, CgenSupport.ACC, s);
						s.println();
						
						s.println("# Restore the new object");
						CgenSupport.emitPop(CgenSupport.ACC, m, s);
						s.println();

						s.println("# Initialize " + a.name);
						CgenSupport.emitStore(CgenSupport.T1, offset,
								CgenSupport.ACC, s);
						s.println();
					}
					offset++;
				}
				catch (ClassCastException ex)
				{
					continue;
				}
			}
a2813 1
		// $a0 now contains the new object.
@


1.21
log
@30/63
@
text
@a10 1
import java.util.Stack;
@


1.20
log
@30/63
@
text
@a429 1
	public int classTag;
a447 1
		classTag = 0;
d1566 1
a1566 1
					Utilities.getDefaultAddress(type_decl), s);
d2899 1
@


1.19
log
@30/63
@
text
@d2814 1
d2901 1
a2901 1
						a.init.code(c, m, env, s);
@


1.18
log
@30/63
@
text
@d27 1
a27 1
	public abstract void cgen(PrintStream s);
d234 1
a234 1
	public abstract void code(CgenNode c, method m, CgenClassTable env, PrintStream s);
d407 1
a407 1
	public void cgen(PrintStream s)
d775 1
a775 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d882 1
a882 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1021 1
a1021 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1136 1
a1136 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1153 3
d1159 1
d1260 1
a1260 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1389 1
a1389 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1446 1
a1446 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1548 1
a1548 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1662 1
a1662 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1759 1
a1759 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1857 1
a1857 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d1956 1
a1956 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2058 1
a2058 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2144 1
a2144 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2269 1
a2269 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2383 1
a2383 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2501 1
a2501 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2605 1
a2605 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2663 1
a2663 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2719 1
a2719 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2776 1
a2776 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d2778 2
d2823 3
a2825 2
			// Initialise attributes of the object with default values
			int i = CgenSupport.DEFAULT_OBJFIELDS;
d2827 1
a2827 1
					.getFeatures().getElements(); e.hasMoreElements(); i++)
d2840 4
a2843 4
						// Create a new object representing the default type of
						// the attribute
						// A call to object.copy does this as prototype objects
						// represent default values
d2845 2
d2849 1
d2851 1
a2851 1
						// Restore reference to the new object
d2853 1
d2855 2
a2856 3
						// Initialise i'th attribute of new object with its
						// respective default
						CgenSupport.emitStore(CgenSupport.T1, i,
d2858 1
d2861 4
a2864 2
					{// non-String, non-Int, non-Bool attributes are
						// initialized to void
d2867 1
a2867 1
						CgenSupport.emitStore(CgenSupport.T1, i,
d2870 1
d2878 3
a2880 4
			// Initialise attributes of the object with initializers
			// Note that the new object is in ACC and thus acts as the self
			// object
			i = CgenSupport.DEFAULT_OBJFIELDS;
d2882 1
a2882 1
					.getFeatures().getElements(); e.hasMoreElements(); i++)
d2887 6
a2892 1
					if (a.init != null)
d2894 2
a2895 1
						// Save reference to the new object
d2897 1
d2899 1
d2901 1
d2903 1
d2906 3
d2910 1
d2912 2
a2913 1
						CgenSupport.emitStore(CgenSupport.T1, i,
d2915 1
d2917 1
d2926 2
d2978 1
a2978 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d3061 1
a3061 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d3110 1
a3110 1
	public void code(CgenNode c, method m, CgenClassTable env, PrintStream s)
d3114 2
d3128 2
@


1.17
log
@25/63
@
text
@d227 8
a234 1
	public abstract void code(CgenNode c, method m, SymbolTable env, PrintStream s);
d430 1
d449 1
d775 1
a775 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d882 1
a882 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d998 16
d1021 1
a1021 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1059 1
a1059 1
		
d1136 1
a1136 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1166 3
a1168 1
		int nItems = m.nItems;
d1182 2
a1183 1
		m.nItems = nItems;
d1256 1
a1256 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1385 1
a1385 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1442 1
a1442 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1544 1
a1544 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1658 1
a1658 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1755 1
a1755 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1853 1
a1853 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d1952 1
a1952 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2054 1
a2054 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2140 1
a2140 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2265 1
a2265 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2379 1
a2379 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2497 1
a2497 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2601 1
a2601 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2659 1
a2659 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2715 1
a2715 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2772 1
a2772 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d2846 1
a2846 1
						CgenSupport.emitStore(CgenSupport.T1, i * 4,
d2946 1
a2946 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d3029 1
a3029 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
d3078 1
a3078 1
	public void code(CgenNode c, method m, SymbolTable env, PrintStream s)
@


1.16
log
@25/63
@
text
@d1048 1
a1048 1
		s.println();
d2747 3
a2749 1
		{// Incomplete
d2784 1
a2784 1
			// Create new object
d2786 2
d2790 1
a2790 1
			int i = 0;
d2801 1
a2801 1
						// Save reference to the new object
d2803 1
d2826 1
a2826 1
						CgenSupport.emitStore(CgenSupport.T1, i * 4,
d2839 1
a2839 1
			i = 0;
d2857 1
a2857 1
						CgenSupport.emitStore(CgenSupport.T1, i * 4,
@


1.15
log
@24/63
@
text
@d875 52
a987 31
	public int getMethodOffset(CgenNode c, AbstractSymbol methodName)
	{
		LinkedList<CgenNode> q = new LinkedList<CgenNode>();
		
		q.add(c);
		while(c.getParentNd() != null)
		{
			c = c.getParentNd();
			q.add(c);
			
		}
			
		while(!q.isEmpty())
		{
			CgenNode nd = q.remove();
			for(Enumeration e = nd.getFeatures().getElements(); e.hasMoreElements(); )
			{
				try
				{
					method m = (method)e.nextElement();
					if (m.name.toString().equals(methodName.toString()))
						return m.methodOffset;
				}
				catch (ClassCastException ex)
				{
					;
				}
			}
		}
		return 0;
	}
d1038 1
a1038 1
		CgenSupport.emitLoad(CgenSupport.T1, getMethodOffset(nd, name),
@


1.14
log
@23/63
@
text
@d2013 10
d2024 5
a2028 3
		s.println("# Negate the value in the resulting object");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitNeg(CgenSupport.T1, CgenSupport.T1, s);
a2483 2
//		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_TRUE, s);
	//	CgenSupport.emitStoreBool(CgenSupport.T1, CgenSupport.ACC, s);
a2497 2
//		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_FALSE, s);
//		CgenSupport.emitStoreBool(CgenSupport.T1, CgenSupport.ACC, s);
@


1.13
log
@23/63
@
text
@d2442 1
a2442 1
		int makeFalseLabel = CgenSupport.getLabel();
d2461 2
a2462 2
		s.println("# If operand is true, branch to label" + makeFalseLabel);
		CgenSupport.emitBeq(CgenSupport.T1, CgenSupport.ACC, makeFalseLabel, s);
d2465 1
a2465 1
		s.println("# Make true branch");
d2470 4
a2473 3
		s.println("# Make true");
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_TRUE, s);
		CgenSupport.emitStoreBool(CgenSupport.T1, CgenSupport.ACC, s);
d2478 2
a2479 2
		s.println("# Make False branch");
		CgenSupport.emitLabelDef(makeFalseLabel, s);
d2486 4
a2489 3
		s.println("# Make False");
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_FALSE, s);
		CgenSupport.emitStoreBool(CgenSupport.T1, CgenSupport.ACC, s);
@


1.12
log
@22/63
@
text
@d508 1
d936 1
a936 1
	public int getOffsetToDispatchMethod(CgenNode c)
d938 11
a948 7
		Stack<CgenNode> s = new Stack<CgenNode>();
		s.push(c);
		while (s.peek().getParentNd() != null)
			s.push(s.peek().getParentNd());

		int offset = 0;
		while (!s.isEmpty())
d950 2
a951 2
			CgenNode nd = s.pop();
			for (Enumeration e = nd.features.getElements(); e.hasMoreElements();)
d955 3
a957 5
					method m = (method) (e.nextElement());
					if (m.name.toString().equals(name.toString()))
						return offset;
					offset++;

d961 1
a961 1

d965 1
a965 2
		return offset;

d1013 5
a1017 1
		CgenSupport.emitLoad(CgenSupport.T1, getOffsetToDispatchMethod(c),
d2460 1
d2476 1
d2910 1
a2910 1
		s.println("# True branch");
@


1.11
log
@20/63
@
text
@d1209 3
a1211 3
		s.println("# Get reference to 'false' constant");
		CgenSupport.emitLoadAddress(CgenSupport.T1,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
d1217 4
d1222 2
a1223 2
		s.println("# Save self object before evaluating predicate. " +
				"Will need it to evaluate the body of the loop");
d1226 1
a1226 1
		
d1231 7
a1237 2
		s.println("# The test. Did the predicate evaluate to 'false'?" +
				"If it did jump to label" + endLabel);
d1244 5
d1259 1
a1259 1
		s.println("# End of loop. Set return value to void");
d1261 6
@


1.10
log
@19/63
@
text
@d783 2
a784 2
		s.println("# Self object is needed as the subsequent store might be " +
				"w.r.t to the self object");
d1111 4
d1128 1
d1379 2
a1380 2
			s.println("# Save self object before evaluating this expression. " 
					+ "Will need it to evaluate the subsequent expressions");
d2185 2
a2186 1
		s.println("# Save self object");
@


1.9
log
@15/63
@
text
@d767 1
a767 1
		s.println("\t# assign expression");
d770 1
a770 1
		s.println("\t# Save self object");
d774 1
a774 1
		s.println("\t# Evaluate the RHS and get the reference in $a0");
d778 1
a778 1
		s.println("\t# Temporarily cache the result");
d782 2
a783 2
		s.println("\t# Restore the self object");
		s.println("\t# Self object is needed as the subsequent store might be " +
d790 1
a790 1
		s.println("\t# Store the result in the location of the variable");
d794 1
a794 1
		s.println("\t# De-cache the result. It must be in $a0");
d797 1
a797 1
		s.println("\t# End of assign expression");
d975 1
a975 1
		s.println("\t# Method dispatch\n");
d977 1
a977 1
		s.println("\t# Save FP");
d983 1
a983 1
			s.println("\t# Save self");
d988 1
a988 1
			s.println("\t# Evaluate actual argument and get it in in $a0");
d992 1
a992 1
			s.println("\t# Temporarily cache evaluated argument");
d996 1
a996 1
			s.println("\t# Restore self");
d1000 1
a1000 1
			s.println("\t# Push argument in Stack");
d1005 1
a1005 1
		s.println("\t# Evaluate invoking object and Get it in $a0");
d1009 1
a1009 1
		s.println("\t# Get reference to dispatch method");
d1015 1
a1015 1
		s.println("\t# Dispatch");
d1019 1
a1019 1
		s.println("\t# Restore FP");
d1086 1
a1086 1
		s.println("\t# If-then-else");
d1092 2
a1093 2
		s.println("\t# Save self object before evaluating predicate. " +
				"Will need it to evaluate then-expression and else-expression");
d1097 1
a1097 1
		s.println("\t# Evaluate predicate and get reference in $a0");
d1101 1
a1101 1
		s.println("\t# Get reference to 'false' constant");
d1106 2
a1107 2
		s.println("\t# The test. Did the predicate evaluate to 'false'?" +
				"If it did jump to label" + elseLabel);
d1111 2
a1112 2
		s.println("\t# If-Then Branch");
		s.println("\t# Retrieve self object before evaluating the then-expr");
d1116 1
a1116 1
		s.println("\t# Evaluate the then-expr and get reference in $a0");
d1120 1
a1120 1
		s.println("\t# End of if-then. Branch to label" + endLabel);
d1124 1
a1124 1
		s.println("\t# The else branch");
d1128 1
a1128 1
		s.println("\t# Retrieve self object before evaluating the else-expr");
d1132 1
a1132 1
		s.println("\t# Evaluate the else-expr and get reference in $a0");
d1136 1
a1136 1
		s.println("\t# End of if-then-else");
d1198 1
a1198 1
		s.println("\t# while loop");
d1204 1
a1204 1
		s.println("\t# Get reference to 'false' constant");
d1209 1
a1209 1
		s.println("\t# Loop");
d1213 1
a1213 1
		s.println("\t# Save self object before evaluating predicate. " +
d1218 1
a1218 1
		s.println("\t# Evaluate predicate and get reference in $a0");
d1222 1
a1222 1
		s.println("\t# The test. Did the predicate evaluate to 'false'?" +
d1227 1
a1227 1
		s.println("\t# Retrieve self object before evaluating the body");
d1231 1
a1231 1
		s.println("\t# Evaluate the body and get reference in $a0");
d1235 1
a1235 1
		s.println("\t# Go back to label" + loopLabel 
d1240 1
a1240 1
		s.println("\t# End of loop. Set return value to void");
d1364 1
a1364 1
		s.println("\t# Start of block");
d1374 1
a1374 1
			s.println("\t# Save self object before evaluating this expression. " 
d1379 1
a1379 1
			s.println("\t# Evaluate the expression and " +
d1384 1
a1384 1
			s.println("\t# Retrieve self object before evaluating the next " +
d1389 1
a1389 1
		s.println("\t# Evaluate the last expression and " +
d1394 1
a1394 1
		s.println("\t# End of block");
d1467 1
a1467 1
		s.println("\t# let expression");
d1472 1
a1472 1
		s.println("\t# Save the self object before evaluating the " +
d1474 1
a1474 1
		s.println("\t# Will need it while evaluating the body of the let");
d1481 1
a1481 1
			s.println("\t# No Initializer. Get the reference to the default " +
d1489 1
a1489 1
			s.println("\t# Evaluate the initializer and get the reference in " +
d1495 1
a1495 1
		s.println("\t# Temporarily hold the let identifier");
d1499 1
a1499 1
		s.println("\t# Restore the self object");
d1503 1
a1503 1
		s.println("\t# Save the let variable in the stack");
d1505 3
a1507 1
		env.addId(identifier, m.nItems - 1); // Incomplete : Explain how
d1510 2
a1511 1
		s.println("\t# Evaluate let-body and get the reference in $a0");
d1515 1
a1515 1
		s.println("\t# Remove the let variable introduced");
d1520 1
a1520 1
		s.println("\t# let expression ends");
d1580 1
a1580 1
		s.println("\t# + expression");
d1583 2
a1584 2
		s.println("\t#Save reference to self object.");
		s.println("\t# Needed while evaluating the second operand");
d1587 1
a1587 1
		s.println("\t# evaluate the first operand and get reference in $a0");
d1590 1
a1590 1
		s.println("\t# Get the value of the first operand");
d1593 1
a1593 1
		s.println("\t# Restore the self object before evaluating the second operand");
d1596 1
a1596 1
		s.println("\t# Save the value of the first operand in the stack");
d1599 1
a1599 1
		s.println("\t# evaluate the second operand and get reference in $a0");
d1602 1
a1602 1
		s.println("\t# Get the value of the first operand");
d1605 1
a1605 1
		s.println("\t# Restore the value of the first operand from the stack");
d1608 1
a1608 1
		s.println("\t# Compute and then save result in stack");
d1613 1
a1613 1
		s.println("\t# Create new object to store the result");
d1616 1
a1616 1
		s.println("\t# Store result in new object");
d1677 1
a1677 1
		s.println("\t# - expression");
d1680 2
a1681 2
		s.println("\t#Save reference to self object.");
		s.println("\t# Needed while evaluating the second operand");
d1684 1
a1684 1
		s.println("\t# evaluate the first operand and get reference in $a0");
d1687 1
a1687 1
		s.println("\t# Get the value of the first operand");
d1690 1
a1690 1
		s.println("\t# Restore the self object before evaluating the second operand");
d1693 1
a1693 1
		s.println("\t# Save the value of the first operand in the stack");
d1696 1
a1696 1
		s.println("\t# evaluate the second operand and get reference in $a0");
d1699 1
a1699 1
		s.println("\t# Get the value of the first operand");
d1702 1
a1702 1
		s.println("\t# Restore the value of the first operand from the stack");
d1705 1
a1705 1
		s.println("\t# Compute and then save result in stack");
d1710 1
a1710 1
		s.println("\t# Create new object to store the result");
d1713 1
a1713 1
		s.println("\t# Store result in new object");
d1775 1
a1775 1
		s.println("\t# * expression");
d1778 2
a1779 2
		s.println("\t#Save reference to self object.");
		s.println("\t# Needed while evaluating the second operand");
d1782 1
a1782 1
		s.println("\t# evaluate the first operand and get reference in $a0");
d1785 1
a1785 1
		s.println("\t# Get the value of the first operand");
d1788 1
a1788 1
		s.println("\t# Restore the self object before evaluating the second operand");
d1791 1
a1791 1
		s.println("\t# Save the value of the first operand in the stack");
d1794 1
a1794 1
		s.println("\t# evaluate the second operand and get reference in $a0");
d1797 1
a1797 1
		s.println("\t# Get the value of the first operand");
d1800 1
a1800 1
		s.println("\t# Restore the value of the first operand from the stack");
d1803 1
a1803 1
		s.println("\t# Compute and then save result in stack");
d1808 1
a1808 1
		s.println("\t# Create new object to store the result");
d1811 1
a1811 1
		s.println("\t# Store result in new object");
d1874 1
a1874 1
		s.println("\t# / expression");
d1877 2
a1878 2
		s.println("\t#Save reference to self object.");
		s.println("\t# Needed while evaluating the second operand");
d1882 1
a1882 1
		s.println("\t# evaluate the first operand and get reference in $a0");
d1886 1
a1886 1
		s.println("\t# Get the value of the first operand");
d1890 1
a1890 1
		s.println("\t# Restore the self object before evaluating the second operand");
d1894 1
a1894 1
		s.println("\t# Save the value of the first operand in the stack");
d1898 1
a1898 1
		s.println("\t# evaluate the second operand and get reference in $a0");
d1902 1
a1902 1
		s.println("\t# Get the value of the first operand");
d1906 1
a1906 1
		s.println("\t# Restore the value of the first operand from the stack");
d1910 1
a1910 1
		s.println("\t# Compute and then save result in stack");
d1916 1
a1916 1
		s.println("\t# Create new object to store the result");
d1920 1
a1920 1
		s.println("\t# Store result in new object");
d1976 1
a1976 1
		s.println("\t# neg expression");
d1979 1
a1979 1
		s.println("\t# Evaluate the operand and get reference in $a0");
d1983 1
a1983 1
		s.println("\t# Negate the value in the resulting object");
d1989 1
a1989 1
		s.println("\t# End of neg expression");
d2050 2
a2051 2
		s.println("\t# < expression");
		s.println("\t# ");
d2055 1
a2055 1
		s.println("\t# Save self object. Needed during evaluation of the 2nd " +
d2060 1
a2060 1
		s.println("\t#Evaluate 1st operand and get reference in $a0");
d2064 1
a2064 1
		s.println("\t#Get value of 1st operand");
d2068 1
a2068 1
		s.println("\t# Restore self object before evaluation of the 2nd " +
d2073 1
a2073 1
		s.println("\t#Save the value of the 1st operand in the stack");
d2077 1
a2077 1
		s.println("\t# Evaluate the 2nd operand and get reference in $a0");
d2079 1
a2079 1
		s.println("\t#");
d2081 1
a2081 1
		s.println("\t# Get the value of the 2nd operand");
d2085 1
a2085 1
		s.println("\t# Restore the value of the first operand");
d2089 1
a2089 1
		s.println("\t# The test. Branch to label" + trueLabel + " if true");
d2094 2
a2095 2
		s.println("\t# False part");
		s.println("\t# Set return value to the boolean constant, false");
d2100 1
a2100 1
		s.println("\t#Branch to the end, label" + endLabel);
d2102 1
a2102 1
		s.println("\t#");
d2104 1
a2104 1
		s.println("\t# True part");
d2108 1
a2108 1
		s.println("\t# Set return value to the boolean constant, true");
d2113 1
a2113 1
		s.println("\t# End of < expression");
d2178 1
a2178 1
		s.println("\t# '=' expression");
d2180 1
a2180 1
		s.println("\t# Save self object");
d2184 1
a2184 1
		s.println("\t# Evaluate the 1st operand and get reference in $a0");
d2188 1
a2188 1
		s.println("\t# Temporarily cache the 1st operand");
d2191 1
a2191 1
		s.println("\t# Restore self object to evaluate the 2nd operand");
d2195 1
a2195 1
		s.println("\t# Save the first operand");
d2199 1
a2199 1
		s.println("\t# Evaluate the 2nd operand and get reference in $a0");
d2203 1
a2203 1
		s.println("\t# Move 2nd operand into $t2 to do the equality testing");
d2207 1
a2207 1
		s.println("\t# Restore 1st operand into $t1 to do the equality testing");
d2210 1
a2210 1
		s.println("\t# Are both operands the same object?. If yes go to label" +
d2215 1
a2215 1
		s.println("\t# equality test");
d2223 1
a2223 1
		s.println("\t# True Label. Return true");
d2288 2
a2289 2
		s.println("\t# < expression");
		s.println("\t# ");
d2293 1
a2293 1
		s.println("\t# Save self object. Needed during evaluation of the 2nd " +
d2298 1
a2298 1
		s.println("\t#Evaluate 1st operand and get reference in $a0");
d2302 1
a2302 1
		s.println("\t#Get value of 1st operand");
d2306 1
a2306 1
		s.println("\t# Restore self object before evaluation of the 2nd " +
d2311 1
a2311 1
		s.println("\t#Save the value of the 1st operand in the stack");
d2315 1
a2315 1
		s.println("\t# Evaluate the 2nd operand and get reference in $a0");
d2317 1
a2317 1
		s.println("\t#");
d2319 1
a2319 1
		s.println("\t# Get the value of the 2nd operand");
d2323 1
a2323 1
		s.println("\t# Restore the value of the first operand");
d2327 1
a2327 1
		s.println("\t# The test. Branch to label" + trueLabel + " if true");
d2332 2
a2333 2
		s.println("\t# False part");
		s.println("\t# Set return value to the boolean constant, false");
d2338 1
a2338 1
		s.println("\t#Branch to the end, label" + endLabel);
d2340 1
a2340 1
		s.println("\t#");
d2342 1
a2342 1
		s.println("\t# True part");
d2346 1
a2346 1
		s.println("\t# Set return value to the boolean constant, true");
d2351 1
a2351 1
		s.println("\t# End of < expression");
d2406 1
a2406 1
		s.println("\t# Complement expression");
d2412 1
a2412 1
		s.println("\t# Evaluate the operand");
d2416 1
a2416 1
		s.println("\t# Fetch the boolean value of the operand");
d2420 1
a2420 1
		s.println("\t# Save the operand");
d2424 1
a2424 1
		s.println("\t# Get the 'true' value");
d2428 1
a2428 1
		s.println("\t# If operand is true, branch to label" + makeFalseLabel);
d2432 2
a2433 2
		s.println("\t# Make true branch");
		s.println("\t# Restore operand");
d2437 1
a2437 1
		s.println("\t# Make true");
d2443 1
a2443 1
		s.println("\t# Make False branch");
d2447 1
a2447 1
		s.println("\t# Restore operand");
d2451 1
a2451 1
		s.println("\t# Make False");
d2456 1
a2456 1
		s.println("\t# End of complement expression");
d2510 1
a2510 1
		s.println("\t# Integer constant");
d2568 1
a2568 1
		s.println("\t# Boolean constant");
d2624 1
a2624 1
		s.println("\t# String constant");
d2850 1
a2850 1
		s.println("\t# isvoid expression");
d2856 1
a2856 1
		s.println("\t# Evaluate the operand and get reference in $a0");
d2860 1
a2860 1
		s.println("\t# Get the class tag of the object");
d2864 1
a2864 1
		s.println("\t #isvoid?? Branch to the 'false' branch if not void, label" 
d2870 2
a2871 2
		s.println("\t# True branch");
		s.println("\t# Return value is true");
d2876 1
a2876 1
		s.println("\t# True branch");
d2879 1
a2879 1
		s.println("\t# Return value is true");
d2883 1
a2883 1
		s.println("\t# End of isvoid expression");
d2986 1
a2986 1
			s.println("\t# Invoking object is the same as self");
d2992 1
a2992 1
			s.println("\t# Get the object address");
@


1.8
log
@18/63
@
text
@d227 1
a227 1
	public abstract void code(CgenNode c, SymbolTable env, int nItems, PrintStream s);
d507 1
d526 1
d765 1
a765 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d771 1
a771 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d775 1
a775 1
		expr.code(c, env, nItems, s);
d785 1
a785 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d872 1
a872 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d973 1
a973 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d978 1
a978 1
		CgenSupport.emitPush(CgenSupport.FP, nItems, s);
d984 1
a984 1
			CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d989 1
a989 1
			ex.code(c, env, nItems, s);
d997 1
a997 1
			CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1001 1
a1001 1
			CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d1006 1
a1006 1
		expr.code(c, env, nItems, s);
d1020 1
a1020 1
		CgenSupport.emitPop(CgenSupport.FP, nItems, s);
d1084 1
a1084 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1094 1
a1094 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1098 1
a1098 1
		pred.code(c, env, nItems, s);
d1113 1
a1113 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1117 1
a1117 1
		then_exp.code(c, env, nItems, s);
d1129 1
a1129 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1133 1
a1133 1
		else_exp.code(c, env, nItems, s);
d1196 1
a1196 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1215 1
a1215 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1219 1
a1219 1
		pred.code(c, env, nItems, s);
d1228 1
a1228 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1232 1
a1232 1
		body.code(c, env, nItems, s);
d1305 1
a1305 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1362 1
a1362 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1376 1
a1376 1
			CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1381 1
a1381 1
			((Expression) (e.nextElement())).code(c, env, nItems, s);
d1386 1
a1386 1
			CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1391 1
a1391 1
		((Expression) (e.nextElement())).code(c, env, nItems, s);
d1464 1
a1464 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1475 1
a1475 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1491 1
a1491 1
			init.code(c, env, nItems, s);
d1500 1
a1500 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1504 2
a1505 2
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
		env.addId(identifier, nItems - 1); // Incomplete : Explain how
d1509 1
a1509 1
		body.code(c, env, nItems, s);
d1513 1
a1513 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1575 1
a1575 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1582 1
a1582 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1585 1
a1585 1
		e1.code(c, env, nItems, s);
d1591 1
a1591 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1594 1
a1594 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d1597 1
a1597 1
		e2.code(c, env, nItems, s);
d1603 1
a1603 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1608 1
a1608 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1611 1
a1611 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, nItems, s);
d1614 1
a1614 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1672 1
a1672 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1679 1
a1679 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1682 1
a1682 1
		e1.code(c, env, nItems, s);
d1688 1
a1688 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1691 1
a1691 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d1694 1
a1694 1
		e2.code(c, env, nItems, s);
d1700 1
a1700 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1705 1
a1705 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1708 1
a1708 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, nItems, s);
d1711 1
a1711 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1770 1
a1770 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1777 1
a1777 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1780 1
a1780 1
		e1.code(c, env, nItems, s);
d1786 1
a1786 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1789 1
a1789 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d1792 1
a1792 1
		e2.code(c, env, nItems, s);
d1798 1
a1798 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1803 1
a1803 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1806 1
a1806 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, nItems, s);
d1809 1
a1809 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1869 1
a1869 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1876 1
a1876 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1880 1
a1880 1
		e1.code(c, env, nItems, s);
d1888 1
a1888 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d1892 1
a1892 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d1896 1
a1896 1
		e2.code(c, env, nItems, s);
d1904 1
a1904 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1910 1
a1910 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d1914 1
a1914 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, nItems, s);
d1918 1
a1918 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d1971 1
a1971 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d1977 1
a1977 1
		e1.code(c, env, nItems, s);
d2045 1
a2045 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2054 1
a2054 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2058 1
a2058 1
		e1.code(c, env, nItems, s);
d2067 1
a2067 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2071 1
a2071 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d2075 1
a2075 1
		e2.code(c, env, nItems, s);
d2083 1
a2083 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d2170 1
a2170 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2178 1
a2178 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2182 1
a2182 1
		e1.code(c, env, nItems, s);
d2189 1
a2189 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2193 1
a2193 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d2197 1
a2197 1
		e2.code(c, env, nItems, s);
d2205 1
a2205 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d2283 1
a2283 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2292 1
a2292 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2296 1
a2296 1
		e1.code(c, env, nItems, s);
d2305 1
a2305 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2309 1
a2309 1
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);
d2313 1
a2313 1
		e2.code(c, env, nItems, s);
d2321 1
a2321 1
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);
d2401 1
a2401 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2410 1
a2410 1
		e1.code(c, env, nItems, s);
d2418 1
a2418 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2431 1
a2431 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2445 1
a2445 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2505 1
a2505 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2563 1
a2563 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2619 1
a2619 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2676 1
a2676 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2704 1
a2704 1
			CgenSupport.emitPush(CgenSupport.FP, nItems, s);
d2707 1
a2707 1
			CgenSupport.emitPop(CgenSupport.FP, nItems, s);
d2715 1
a2715 1
			CgenSupport.emitCallObjectCopy(type_name, nItems, s);
d2730 1
a2730 1
						CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2736 1
a2736 1
						CgenSupport.emitCallObjectCopy(a.type_decl, nItems, s);
d2741 1
a2741 1
						CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2776 1
a2776 1
						CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2778 1
a2778 1
						a.init.code(c, env, nItems, s);
d2782 1
a2782 1
						CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2845 1
a2845 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2854 1
a2854 1
		e1.code(c, env, nItems, s);
d2928 1
a2928 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2977 1
a2977 1
	public void code(CgenNode c, SymbolTable env, int nItems, PrintStream s)
d2988 2
d2991 1
@


1.7
log
@11/63
@
text
@d776 1
a776 1
		s.println("\t# Temporarily save the result");
d792 3
d1503 1
a1503 1
		env.addId(identifier, nItems - 2); // Incomplete : Explain how
@


1.6
log
@11/63
@
text
@d1473 2
a1474 1
		if (init == null)
d1500 1
a1500 1
		env.addId(identifier, nItems - 1);
d2924 1
a2924 1
	{
@


1.5
log
@8/63
@
text
@a1086 5
		s.println("\t# Get reference to 'false' constant");
		CgenSupport.emitLoadAddress(CgenSupport.T1,
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);
		s.println();

d1096 5
d2168 2
a2169 2

		s.println("\t# = expression");
d2175 1
a2175 1
		s.println("\t# Evaluate LHS and get reference in $a0");
d2179 3
d2184 1
d2186 5
a2190 9
/*		s.println("\t# Get value in $a0");
		CgenSupport.emitFetchInt(CgenSupport.T1, CgenSupport.ACC, s);
		s.println("\t# Restore self object");*/
		CgenSupport.emitMove(CgenSupport.T1, CgenSupport.ACC, s);

/*		s.println("\t# Save value of LHS");
		CgenSupport.emitPush(CgenSupport.T1, nItems, s);*/

		s.println("\t# Evaluate RHS and get reference in $a0");
d2192 15
a2206 10
/*		s.println("\t# Get value in $a0");
		CgenSupport.emitFetchInt(CgenSupport.ACC, CgenSupport.ACC, s);
		s.println("\t# Retrieve value of RHS in $a0");
		CgenSupport.emitPop(CgenSupport.T1, nItems, s);*/

		s.println("\t# The test");
		CgenSupport.emitBeq(CgenSupport.T1, CgenSupport.ACC, trueLabel, s);

		/** False **/
		s.println("\t# False");
d2208 2
d2211 1
d2213 2
a2214 3

		/** True **/
		s.println("\t# True");
d2217 2
a2218 2
				CgenSupport.BOOLCONST_PREFIX + CgenSupport.BOOL_FALSE, s);

d2501 1
d2506 1
d2559 1
d2561 1
d2615 1
d2619 1
d2841 3
a2843 1

d2847 1
a2847 1
		// Get reference to the value of e1 in ACC
d2849 1
d2851 1
a2851 1
		// Get the class tag of the object
d2853 1
d2855 2
a2856 1
		// Jump to the 'false' branch if not void
d2859 1
d2861 3
a2863 3
		// True branch
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, nItems, s);
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_TRUE, s);
d2865 1
d2867 1
a2867 1
		// False branch
d2869 4
a2872 2
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, nItems, s);
		CgenSupport.emitLoadImm(CgenSupport.T1, CgenSupport.BOOL_FALSE, s);
d2874 1
a2874 1
		// End
d2877 1
@


1.4
log
@9/63
@
text
@d765 8
d774 12
d787 7
a793 1
		CgenSupport.emitStore(CgenSupport.ACC, a.offset, a.reg, s);
a794 1

d987 1
a987 1
			s.println("\t# Save evaluated argument");
a997 2
			
			//env.addId(name, nItems - 1);
d1359 1
a1359 1
		s.println("\t# End of block");
d1588 1
a1588 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d1685 1
a1685 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d1783 1
a1783 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d1886 1
a1886 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d2065 1
a2065 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d2296 1
a2296 1
		CgenSupport.emitPush(CgenSupport.T1, s);
d2390 3
d2396 1
d2398 3
d2402 1
d2404 1
d2406 3
d2410 1
d2412 1
d2414 1
d2416 2
a2417 1
		/** make True **/
d2419 5
a2423 3
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_TRUE).toString(), CgenSupport.T1,
				s);
d2425 1
d2427 1
a2427 1
		/** make False **/
d2429 3
d2433 8
a2440 4
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_FALSE).toString(), CgenSupport.T1,
				s);

d2442 1
a2442 1
		CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);
@


1.3
log
@*** empty log message ***
@
text
@d1574 1
a1574 1
		CgenSupport.emitPop(CgenSupport.T1, s);
d1671 1
a1671 1
		CgenSupport.emitPop(CgenSupport.T1, s);
d1769 1
a1769 1
		CgenSupport.emitPop(CgenSupport.T1, s);
d1848 1
d1852 1
d1856 1
d1860 1
d1864 1
d1868 1
d1872 1
d1875 2
a1876 1
		CgenSupport.emitPop(CgenSupport.T1, s);
d1882 1
d1886 1
d1891 1
d1944 4
d1949 3
d1954 5
d2018 2
d2023 2
d2026 3
d2030 3
d2034 4
d2039 1
d2041 5
a2045 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2047 3
d2051 1
d2053 5
d2059 1
d2062 7
a2068 5
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, nItems, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_FALSE).toString(), CgenSupport.T1,
				s);
d2070 1
d2072 1
a2072 1
		/** True **/
d2074 10
a2083 4
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_TRUE).toString(), CgenSupport.T1,
				s);
a2084 2
		CgenSupport.emitLabelDef(endLabel, s);
		CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);
d2146 2
d2150 2
d2154 5
d2163 1
a2163 1
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
d2249 2
d2254 2
d2257 3
d2261 3
d2265 4
d2270 1
d2272 5
a2276 1
		CgenSupport.emitPush(CgenSupport.ACC, nItems, s);
d2278 3
d2282 1
d2284 5
d2290 1
d2293 7
a2299 5
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, nItems, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_FALSE).toString(), CgenSupport.T1,
				s);
d2301 1
d2303 1
a2303 1
		/** True **/
d2305 8
a2312 5
		CgenSupport.emitPop(CgenSupport.ACC, nItems, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_TRUE).toString(), CgenSupport.T1,
				s);

d2314 1
a2314 2
		CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);
	}
@


1.2
log
@Hello World
@
text
@d227 1
a227 1
	public abstract void code(CgenNode c, SymbolTable env, PrintStream s);
d763 1
a763 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d765 1
a765 1
		expr.code(c, env, s);
d842 1
a842 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d905 1
a905 1
	public int getOffset(CgenNode c)
d916 1
a916 2
			for (Enumeration e = nd.features.getElements(); 
					e.hasMoreElements();)
d943 1
a943 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d945 2
a946 1
		s.println("\t# Method dispatch");
d948 3
a950 1
		CgenSupport.emitPush(CgenSupport.FP, s);
d954 3
a956 2
			CgenSupport.emitPush(CgenSupport.ACC, s); // save self
			
d959 3
a961 3
			ex.code(c, env, s);
			//CgenSupport.emitCallObjectCopy(s);
			
d964 2
d967 3
a969 1
			CgenSupport.emitPop(CgenSupport.ACC, s);
d971 4
a974 1
			CgenSupport.emitPush(CgenSupport.T1, s); // Puch actual parameters into stack
d978 3
a980 1
		expr.code(c, env, s); // Evaluate invoking object
d983 4
a986 1
		CgenSupport.emitLoad(CgenSupport.T1, getOffset(c) , CgenSupport.T1, s);
d989 2
d992 2
a993 1
		CgenSupport.emitPop(CgenSupport.FP, s);
d1056 1
a1056 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1058 3
d1063 2
d1067 1
d1069 11
a1079 1
		pred.code(c, env, s);
d1081 12
a1092 1
		then_exp.code(c, env, s);
d1094 1
d1096 1
d1098 9
a1106 1
		else_exp.code(c, env, s);
d1108 1
d1110 1
d1168 1
a1168 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1170 3
d1175 2
d1179 1
d1181 1
d1183 13
a1195 1
		pred.code(c, env, s);
d1197 12
a1208 1
		body.code(c, env, s);
d1210 1
d1212 1
d1216 1
d1277 1
a1277 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1279 1
d1334 11
a1344 3
	public void code(CgenNode c, SymbolTable env, PrintStream s)
	{
		for (Enumeration e = body.getElements(); e.hasMoreElements();)
d1346 14
a1359 1
			((Expression) (e.nextElement())).code(c, env, s);
d1361 7
a1368 1

d1436 1
a1436 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1438 13
a1450 1
		if (init != null)
d1452 5
a1456 3
			init.code(c, env, s);
			CgenSupport.emitPush(CgenSupport.ACC, s);
			// addId(name, )
d1458 31
d1546 1
a1546 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1548 11
a1558 6
		// Save reference to invoking object
		CgenSupport.emitPush(CgenSupport.ACC, s);

		// evaluate e1.
		e1.code(c, env, s);
		// Get the value of the integer object
d1560 9
d1570 1
a1570 5
		// Invoking object in ACC
		CgenSupport.emitPop(CgenSupport.ACC, s);
		// evaluate e2.
		e2.code(c, env, s);
		// Get the value of the integer object
d1573 7
a1579 4
		// Compute and then save result in stack
		CgenSupport
				.emitAdd(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, s);
d1581 2
a1582 2
		// Create new object to store the result
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, s);
d1584 2
a1585 2
		// Store result
		CgenSupport.emitPop(CgenSupport.T1, s);
a1586 1

d1643 1
a1643 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1645 11
a1655 6
		// Save reference to invoking object
		CgenSupport.emitPush(CgenSupport.ACC, s);

		// evaluate e1.
		e1.code(c, env, s);
		// Get the value of the integer object
d1657 9
d1667 1
a1667 5
		// Invoking object in ACC
		CgenSupport.emitPop(CgenSupport.ACC, s);
		// evaluate e2.
		e2.code(c, env, s);
		// Get the value of the integer object
d1670 7
a1676 4
		// Compute and then save result in stack
		CgenSupport
				.emitSub(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, s);
d1678 2
a1679 2
		// Create new object to store the result
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, s);
d1681 2
a1682 2
		// Store result
		CgenSupport.emitPop(CgenSupport.T1, s);
d1741 1
a1741 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1743 11
a1753 6
		// Save reference to invoking object
		CgenSupport.emitPush(CgenSupport.ACC, s);

		// evaluate e1.
		e1.code(c, env, s);
		// Get the value of the integer object
d1755 9
d1765 1
a1765 5
		// Invoking object in ACC
		CgenSupport.emitPop(CgenSupport.ACC, s);
		// evaluate e2.
		e2.code(c, env, s);
		// Get the value of the integer object
d1768 7
a1774 4
		// Compute and then save result in stack
		CgenSupport
				.emitMul(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, s);
d1776 2
a1777 2
		// Create new object to store the result
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, s);
d1779 2
a1780 2
		// Store result
		CgenSupport.emitPop(CgenSupport.T1, s);
d1840 1
a1840 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1842 11
a1852 6
		// Save reference to invoking object
		CgenSupport.emitPush(CgenSupport.ACC, s);

		// evaluate e1.
		e1.code(c, env, s);
		// Get the value of the integer object
d1854 9
d1864 1
a1864 5
		// Invoking object in ACC
		CgenSupport.emitPop(CgenSupport.ACC, s);
		// evaluate e2.
		e2.code(c, env, s);
		// Get the value of the integer object
d1867 7
a1873 4
		// Compute and then save result in stack
		CgenSupport
				.emitDiv(CgenSupport.ACC, CgenSupport.T1, CgenSupport.ACC, s);
		CgenSupport.emitPush(CgenSupport.ACC, s);
d1875 2
a1876 2
		// Create new object to store the result
		CgenSupport.emitCallObjectCopy(TreeConstants.Int, s);
d1878 2
a1879 2
		// Store result
		CgenSupport.emitPop(CgenSupport.T1, s);
d1931 1
a1931 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1933 1
a1933 1
		e1.code(c, env, s);
d1993 1
a1993 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d1998 2
a1999 2
		CgenSupport.emitPush(CgenSupport.ACC, s);
		e1.code(c, env, s);
d2001 1
a2001 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
d2003 2
a2004 2
		CgenSupport.emitPush(CgenSupport.ACC, s);
		e2.code(c, env, s);
d2010 2
a2011 2
		CgenSupport.emitPop(CgenSupport.ACC, s);
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, s);
d2019 1
a2019 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
d2082 1
a2082 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2087 5
a2091 2
		CgenSupport.emitPush(CgenSupport.ACC, s);
		e1.code(c, env, s);
d2093 9
a2101 4
		CgenSupport.emitPop(CgenSupport.ACC, s);

		CgenSupport.emitPush(CgenSupport.ACC, s);
		e2.code(c, env, s);
d2103 2
d2106 1
d2110 3
a2112 5
		CgenSupport.emitPop(CgenSupport.ACC, s);
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_FALSE).toString(), CgenSupport.T1,
				s);
d2116 1
d2118 2
a2119 4
		CgenSupport.emitPop(CgenSupport.ACC, s);
		CgenSupport.emitStoreBool(
				new Integer(CgenSupport.BOOL_TRUE).toString(), CgenSupport.T1,
				s);
a2121 2
		CgenSupport.emitMove(CgenSupport.ACC, CgenSupport.T1, s);

d2179 1
a2179 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2184 2
a2185 2
		CgenSupport.emitPush(CgenSupport.ACC, s);
		e1.code(c, env, s);
d2187 1
a2187 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
d2189 2
a2190 2
		CgenSupport.emitPush(CgenSupport.ACC, s);
		e2.code(c, env, s);
d2196 2
a2197 2
		CgenSupport.emitPop(CgenSupport.ACC, s);
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, s);
d2205 1
a2205 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
d2263 1
a2263 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2268 1
a2268 1
		e1.code(c, env, s);
d2271 1
a2271 1
		CgenSupport.emitPush(CgenSupport.ACC, s);
d2277 1
a2277 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
d2285 1
a2285 1
		CgenSupport.emitPop(CgenSupport.ACC, s);
a2292 1

d2341 1
a2341 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2397 1
a2397 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2451 1
a2451 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2506 1
a2506 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2534 1
a2534 1
			CgenSupport.emitPush(CgenSupport.FP, s);
d2537 1
a2537 1
			CgenSupport.emitPop(CgenSupport.FP, s);
d2545 1
a2545 1
			CgenSupport.emitCallObjectCopy(type_name, s);
d2560 1
a2560 1
						CgenSupport.emitPush(CgenSupport.ACC, s);
d2566 1
a2566 1
						CgenSupport.emitCallObjectCopy(a.type_decl, s);
d2571 1
a2571 1
						CgenSupport.emitPop(CgenSupport.ACC, s);
d2606 1
a2606 1
						CgenSupport.emitPush(CgenSupport.ACC, s);
d2608 1
a2608 1
						a.init.code(c, env, s);
d2612 1
a2612 1
						CgenSupport.emitPop(CgenSupport.ACC, s);
d2675 1
a2675 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2682 1
a2682 1
		e1.code(c, env, s);
d2692 1
a2692 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, s);
d2697 2
a2698 1
		CgenSupport.emitCallObjectCopy(TreeConstants.Bool, s);
d2748 1
a2748 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2794 1
a2794 4
	 * Generates code for this expression. This method is to be completed
	 * in programming assignment 5. (You may add or remove parameters as
	 * you wish.)
	 * 
d2797 1
a2797 1
	public void code(CgenNode c, SymbolTable env, PrintStream s)
d2803 1
a2803 1
			s.println("\t#Invoking method is the same as self");
d2807 2
a2808 3
		offsetAddress a = Utilities.getAddress(name, c, env);
		CgenSupport.emitAddiu(CgenSupport.ACC, a.reg, a.offset
				* CgenSupport.WORD_SIZE, s);
@


1.1
log
@Initial revision
@
text
@a8 2


d10 2
d15 235
d251 1472
a1722 8
/** Defines simple phylum Program */
abstract class Program extends TreeNode {
    protected Program(int lineNumber) {
        super(lineNumber);
    }
    public abstract void dump_with_types(PrintStream out, int n);
    public abstract void semant();
    public abstract void cgen(PrintStream s);
d1726 45
d1772 37
a1808 10
/** Defines simple phylum Class_ */
abstract class Class_ extends TreeNode {
    protected Class_(int lineNumber) {
        super(lineNumber);
    }
    public abstract void dump_with_types(PrintStream out, int n);
    public abstract AbstractSymbol getName();
    public abstract AbstractSymbol getParent();
    public abstract AbstractSymbol getFilename();
    public abstract Features getFeatures();
d1810 3
d1815 88
a1903 24
/** Defines list phylum Classes
    <p>
    See <a href="ListNode.html">ListNode</a> for full documentation. */
class Classes extends ListNode {
    public final static Class elementClass = Class_.class;
    /** Returns class of this lists's elements */
    public Class getElementClass() {
        return elementClass;
    }
    protected Classes(int lineNumber, Vector elements) {
        super(lineNumber, elements);
    }
    /** Creates an empty "Classes" list */
    public Classes(int lineNumber) {
        super(lineNumber);
    }
    /** Appends "Class_" element to this list */
    public Classes appendElement(TreeNode elem) {
        addElement(elem);
        return this;
    }
    public TreeNode copy() {
        return new Classes(lineNumber, copyElements());
    }
d1906 83
d1990 3
a1992 6
/** Defines simple phylum Feature */
abstract class Feature extends TreeNode {
    protected Feature(int lineNumber) {
        super(lineNumber);
    }
    public abstract void dump_with_types(PrintStream out, int n);
d1996 77
a2073 24
/** Defines list phylum Features
    <p>
    See <a href="ListNode.html">ListNode</a> for full documentation. */
class Features extends ListNode {
    public final static Class elementClass = Feature.class;
    /** Returns class of this lists's elements */
    public Class getElementClass() {
        return elementClass;
    }
    protected Features(int lineNumber, Vector elements) {
        super(lineNumber, elements);
    }
    /** Creates an empty "Features" list */
    public Features(int lineNumber) {
        super(lineNumber);
    }
    /** Appends "Feature" element to this list */
    public Features appendElement(TreeNode elem) {
        addElement(elem);
        return this;
    }
    public TreeNode copy() {
        return new Features(lineNumber, copyElements());
    }
d2076 31
d2108 21
a2128 6
/** Defines simple phylum Formal */
abstract class Formal extends TreeNode {
    protected Formal(int lineNumber) {
        super(lineNumber);
    }
    public abstract void dump_with_types(PrintStream out, int n);
d2132 39
d2172 10
a2181 24
/** Defines list phylum Formals
    <p>
    See <a href="ListNode.html">ListNode</a> for full documentation. */
class Formals extends ListNode {
    public final static Class elementClass = Formal.class;
    /** Returns class of this lists's elements */
    public Class getElementClass() {
        return elementClass;
    }
    protected Formals(int lineNumber, Vector elements) {
        super(lineNumber, elements);
    }
    /** Creates an empty "Formals" list */
    public Formals(int lineNumber) {
        super(lineNumber);
    }
    /** Appends "Formal" element to this list */
    public Formals appendElement(TreeNode elem) {
        addElement(elem);
        return this;
    }
    public TreeNode copy() {
        return new Formals(lineNumber, copyElements());
    }
d2184 87
d2272 7
a2278 16
/** Defines simple phylum Expression */
abstract class Expression extends TreeNode {
    protected Expression(int lineNumber) {
        super(lineNumber);
    }
    private AbstractSymbol type = null;                                 
    public AbstractSymbol get_type() { return type; }           
    public Expression set_type(AbstractSymbol s) { type = s; return this; } 
    public abstract void dump_with_types(PrintStream out, int n);
    public void dump_type(PrintStream out, int n) {
        if (type != null)
            { out.println(Utilities.pad(n) + ": " + type.getString()); }
        else
            { out.println(Utilities.pad(n) + ": _no_type"); }
    }
    public abstract void code(PrintStream s);
d2280 127
d2409 39
d2449 36
a2484 24
/** Defines list phylum Expressions
    <p>
    See <a href="ListNode.html">ListNode</a> for full documentation. */
class Expressions extends ListNode {
    public final static Class elementClass = Expression.class;
    /** Returns class of this lists's elements */
    public Class getElementClass() {
        return elementClass;
    }
    protected Expressions(int lineNumber, Vector elements) {
        super(lineNumber, elements);
    }
    /** Creates an empty "Expressions" list */
    public Expressions(int lineNumber) {
        super(lineNumber);
    }
    /** Appends "Expression" element to this list */
    public Expressions appendElement(TreeNode elem) {
        addElement(elem);
        return this;
    }
    public TreeNode copy() {
        return new Expressions(lineNumber, copyElements());
    }
d2487 16
d2504 9
a2512 1424
/** Defines simple phylum Case */
abstract class Case extends TreeNode {
    protected Case(int lineNumber) {
        super(lineNumber);
    }
    public abstract void dump_with_types(PrintStream out, int n);

}


/** Defines list phylum Cases
    <p>
    See <a href="ListNode.html">ListNode</a> for full documentation. */
class Cases extends ListNode {
    public final static Class elementClass = Case.class;
    /** Returns class of this lists's elements */
    public Class getElementClass() {
        return elementClass;
    }
    protected Cases(int lineNumber, Vector elements) {
        super(lineNumber, elements);
    }
    /** Creates an empty "Cases" list */
    public Cases(int lineNumber) {
        super(lineNumber);
    }
    /** Appends "Case" element to this list */
    public Cases appendElement(TreeNode elem) {
        addElement(elem);
        return this;
    }
    public TreeNode copy() {
        return new Cases(lineNumber, copyElements());
    }
}


/** Defines AST constructor 'program'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class program extends Program {
    public Classes classes;
    /** Creates "program" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for classes
      */
    public program(int lineNumber, Classes a1) {
        super(lineNumber);
        classes = a1;
    }
    public TreeNode copy() {
        return new program(lineNumber, (Classes)classes.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "program\n");
        classes.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_program");
        for (Enumeration e = classes.getElements(); e.hasMoreElements(); ) {
	    ((Class_)e.nextElement()).dump_with_types(out, n + 1);
        }
    }
    /** This method is the entry point to the semantic checker.  You will
        need to complete it in programming assignment 4.
	<p>
        Your checker should do the following two things:
	<ol>
	<li>Check that the program is semantically correct
	<li>Decorate the abstract syntax tree with type information
        by setting the type field in each Expression node.
        (see tree.h)
	</ol>
	<p>
	You are free to first do (1) and make sure you catch all semantic
    	errors. Part (2) can be done in a second stage when you want
	to test the complete compiler.
    */
    public void semant() {
	/* ClassTable constructor may do some semantic analysis */
	ClassTable classTable = new ClassTable(classes);
	
	/* some semantic analysis code may go here */

	if (classTable.errors()) {
	    System.err.println("Compilation halted due to static semantic errors.");
	    System.exit(1);
	}
    }
    /** This method is the entry point to the code generator.  All of the work
      * of the code generator takes place within CgenClassTable constructor.
      * @@param s the output stream 
      * @@see CgenClassTable
      * */
    public void cgen(PrintStream s) 
    {
        // spim wants comments to start with '#'
        s.print("# start of generated code\n");

	CgenClassTable codegen_classtable = new CgenClassTable(classes, s);

	s.print("\n# end of generated code\n");
    }

}


/** Defines AST constructor 'class_'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class class_ extends Class_ {
    public AbstractSymbol name;
    public AbstractSymbol parent;
    public Features features;
    public AbstractSymbol filename;
    /** Creates "class_" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for parent
      * @@param a2 initial value for features
      * @@param a3 initial value for filename
      */
    public class_(int lineNumber, AbstractSymbol a1, AbstractSymbol a2, Features a3, AbstractSymbol a4) {
        super(lineNumber);
        name = a1;
        parent = a2;
        features = a3;
        filename = a4;
    }
    public TreeNode copy() {
        return new class_(lineNumber, copy_AbstractSymbol(name), copy_AbstractSymbol(parent), (Features)features.copy(), copy_AbstractSymbol(filename));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "class_\n");
        dump_AbstractSymbol(out, n+2, name);
        dump_AbstractSymbol(out, n+2, parent);
        features.dump(out, n+2);
        dump_AbstractSymbol(out, n+2, filename);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_class");
        dump_AbstractSymbol(out, n + 2, name);
        dump_AbstractSymbol(out, n + 2, parent);
        out.print(Utilities.pad(n + 2) + "\"");
        Utilities.printEscapedString(out, filename.getString());
        out.println("\"\n" + Utilities.pad(n + 2) + "(");
        for (Enumeration e = features.getElements(); e.hasMoreElements();) {
	    ((Feature)e.nextElement()).dump_with_types(out, n + 2);
        }
        out.println(Utilities.pad(n + 2) + ")");
    }
    public AbstractSymbol getName()     { return name; }
    public AbstractSymbol getParent()   { return parent; }
    public AbstractSymbol getFilename() { return filename; }
    public Features getFeatures()       { return features; }

}


/** Defines AST constructor 'method'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class method extends Feature {
    public AbstractSymbol name;
    public Formals formals;
    public AbstractSymbol return_type;
    public Expression expr;
    /** Creates "method" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for formals
      * @@param a2 initial value for return_type
      * @@param a3 initial value for expr
      */
    public method(int lineNumber, AbstractSymbol a1, Formals a2, AbstractSymbol a3, Expression a4) {
        super(lineNumber);
        name = a1;
        formals = a2;
        return_type = a3;
        expr = a4;
    }
    public TreeNode copy() {
        return new method(lineNumber, copy_AbstractSymbol(name), (Formals)formals.copy(), copy_AbstractSymbol(return_type), (Expression)expr.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "method\n");
        dump_AbstractSymbol(out, n+2, name);
        formals.dump(out, n+2);
        dump_AbstractSymbol(out, n+2, return_type);
        expr.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_method");
        dump_AbstractSymbol(out, n + 2, name);
        for (Enumeration e = formals.getElements(); e.hasMoreElements();) {
	    ((Formal)e.nextElement()).dump_with_types(out, n + 2);
        }
        dump_AbstractSymbol(out, n + 2, return_type);
	expr.dump_with_types(out, n + 2);
    }

}


/** Defines AST constructor 'attr'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class attr extends Feature {
    public AbstractSymbol name;
    public AbstractSymbol type_decl;
    public Expression init;
    /** Creates "attr" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for type_decl
      * @@param a2 initial value for init
      */
    public attr(int lineNumber, AbstractSymbol a1, AbstractSymbol a2, Expression a3) {
        super(lineNumber);
        name = a1;
        type_decl = a2;
        init = a3;
    }
    public TreeNode copy() {
        return new attr(lineNumber, copy_AbstractSymbol(name), copy_AbstractSymbol(type_decl), (Expression)init.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "attr\n");
        dump_AbstractSymbol(out, n+2, name);
        dump_AbstractSymbol(out, n+2, type_decl);
        init.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_attr");
        dump_AbstractSymbol(out, n + 2, name);
        dump_AbstractSymbol(out, n + 2, type_decl);
	init.dump_with_types(out, n + 2);
    }

}


/** Defines AST constructor 'formal'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class formal extends Formal {
    public AbstractSymbol name;
    public AbstractSymbol type_decl;
    /** Creates "formal" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for type_decl
      */
    public formal(int lineNumber, AbstractSymbol a1, AbstractSymbol a2) {
        super(lineNumber);
        name = a1;
        type_decl = a2;
    }
    public TreeNode copy() {
        return new formal(lineNumber, copy_AbstractSymbol(name), copy_AbstractSymbol(type_decl));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "formal\n");
        dump_AbstractSymbol(out, n+2, name);
        dump_AbstractSymbol(out, n+2, type_decl);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_formal");
        dump_AbstractSymbol(out, n + 2, name);
        dump_AbstractSymbol(out, n + 2, type_decl);
    }

}


/** Defines AST constructor 'branch'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class branch extends Case {
    public AbstractSymbol name;
    public AbstractSymbol type_decl;
    public Expression expr;
    /** Creates "branch" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for type_decl
      * @@param a2 initial value for expr
      */
    public branch(int lineNumber, AbstractSymbol a1, AbstractSymbol a2, Expression a3) {
        super(lineNumber);
        name = a1;
        type_decl = a2;
        expr = a3;
    }
    public TreeNode copy() {
        return new branch(lineNumber, copy_AbstractSymbol(name), copy_AbstractSymbol(type_decl), (Expression)expr.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "branch\n");
        dump_AbstractSymbol(out, n+2, name);
        dump_AbstractSymbol(out, n+2, type_decl);
        expr.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_branch");
        dump_AbstractSymbol(out, n + 2, name);
        dump_AbstractSymbol(out, n + 2, type_decl);
	expr.dump_with_types(out, n + 2);
    }

}


/** Defines AST constructor 'assign'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class assign extends Expression {
    public AbstractSymbol name;
    public Expression expr;
    /** Creates "assign" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      * @@param a1 initial value for expr
      */
    public assign(int lineNumber, AbstractSymbol a1, Expression a2) {
        super(lineNumber);
        name = a1;
        expr = a2;
    }
    public TreeNode copy() {
        return new assign(lineNumber, copy_AbstractSymbol(name), (Expression)expr.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "assign\n");
        dump_AbstractSymbol(out, n+2, name);
        expr.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_assign");
        dump_AbstractSymbol(out, n + 2, name);
	expr.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'static_dispatch'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class static_dispatch extends Expression {
    public Expression expr;
    public AbstractSymbol type_name;
    public AbstractSymbol name;
    public Expressions actual;
    /** Creates "static_dispatch" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for expr
      * @@param a1 initial value for type_name
      * @@param a2 initial value for name
      * @@param a3 initial value for actual
      */
    public static_dispatch(int lineNumber, Expression a1, AbstractSymbol a2, AbstractSymbol a3, Expressions a4) {
        super(lineNumber);
        expr = a1;
        type_name = a2;
        name = a3;
        actual = a4;
    }
    public TreeNode copy() {
        return new static_dispatch(lineNumber, (Expression)expr.copy(), copy_AbstractSymbol(type_name), copy_AbstractSymbol(name), (Expressions)actual.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "static_dispatch\n");
        expr.dump(out, n+2);
        dump_AbstractSymbol(out, n+2, type_name);
        dump_AbstractSymbol(out, n+2, name);
        actual.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_static_dispatch");
	expr.dump_with_types(out, n + 2);
        dump_AbstractSymbol(out, n + 2, type_name);
        dump_AbstractSymbol(out, n + 2, name);
        out.println(Utilities.pad(n + 2) + "(");
        for (Enumeration e = actual.getElements(); e.hasMoreElements();) {
	    ((Expression)e.nextElement()).dump_with_types(out, n + 2);
        }
        out.println(Utilities.pad(n + 2) + ")");
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'dispatch'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class dispatch extends Expression {
    public Expression expr;
    public AbstractSymbol name;
    public Expressions actual;
    /** Creates "dispatch" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for expr
      * @@param a1 initial value for name
      * @@param a2 initial value for actual
      */
    public dispatch(int lineNumber, Expression a1, AbstractSymbol a2, Expressions a3) {
        super(lineNumber);
        expr = a1;
        name = a2;
        actual = a3;
    }
    public TreeNode copy() {
        return new dispatch(lineNumber, (Expression)expr.copy(), copy_AbstractSymbol(name), (Expressions)actual.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "dispatch\n");
        expr.dump(out, n+2);
        dump_AbstractSymbol(out, n+2, name);
        actual.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_dispatch");
	expr.dump_with_types(out, n + 2);
        dump_AbstractSymbol(out, n + 2, name);
        out.println(Utilities.pad(n + 2) + "(");
        for (Enumeration e = actual.getElements(); e.hasMoreElements();) {
	    ((Expression)e.nextElement()).dump_with_types(out, n + 2);
        }
        out.println(Utilities.pad(n + 2) + ")");
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'cond'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class cond extends Expression {
    public Expression pred;
    public Expression then_exp;
    public Expression else_exp;
    /** Creates "cond" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for pred
      * @@param a1 initial value for then_exp
      * @@param a2 initial value for else_exp
      */
    public cond(int lineNumber, Expression a1, Expression a2, Expression a3) {
        super(lineNumber);
        pred = a1;
        then_exp = a2;
        else_exp = a3;
    }
    public TreeNode copy() {
        return new cond(lineNumber, (Expression)pred.copy(), (Expression)then_exp.copy(), (Expression)else_exp.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "cond\n");
        pred.dump(out, n+2);
        then_exp.dump(out, n+2);
        else_exp.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_cond");
	pred.dump_with_types(out, n + 2);
	then_exp.dump_with_types(out, n + 2);
	else_exp.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'loop'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class loop extends Expression {
    public Expression pred;
    public Expression body;
    /** Creates "loop" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for pred
      * @@param a1 initial value for body
      */
    public loop(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        pred = a1;
        body = a2;
    }
    public TreeNode copy() {
        return new loop(lineNumber, (Expression)pred.copy(), (Expression)body.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "loop\n");
        pred.dump(out, n+2);
        body.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_loop");
	pred.dump_with_types(out, n + 2);
	body.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'typcase'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class typcase extends Expression {
    public Expression expr;
    public Cases cases;
    /** Creates "typcase" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for expr
      * @@param a1 initial value for cases
      */
    public typcase(int lineNumber, Expression a1, Cases a2) {
        super(lineNumber);
        expr = a1;
        cases = a2;
    }
    public TreeNode copy() {
        return new typcase(lineNumber, (Expression)expr.copy(), (Cases)cases.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "typcase\n");
        expr.dump(out, n+2);
        cases.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_typcase");
	expr.dump_with_types(out, n + 2);
        for (Enumeration e = cases.getElements(); e.hasMoreElements();) {
	    ((Case)e.nextElement()).dump_with_types(out, n + 2);
        }
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'block'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class block extends Expression {
    public Expressions body;
    /** Creates "block" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for body
      */
    public block(int lineNumber, Expressions a1) {
        super(lineNumber);
        body = a1;
    }
    public TreeNode copy() {
        return new block(lineNumber, (Expressions)body.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "block\n");
        body.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_block");
        for (Enumeration e = body.getElements(); e.hasMoreElements();) {
	    ((Expression)e.nextElement()).dump_with_types(out, n + 2);
        }
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'let'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class let extends Expression {
    public AbstractSymbol identifier;
    public AbstractSymbol type_decl;
    public Expression init;
    public Expression body;
    /** Creates "let" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for identifier
      * @@param a1 initial value for type_decl
      * @@param a2 initial value for init
      * @@param a3 initial value for body
      */
    public let(int lineNumber, AbstractSymbol a1, AbstractSymbol a2, Expression a3, Expression a4) {
        super(lineNumber);
        identifier = a1;
        type_decl = a2;
        init = a3;
        body = a4;
    }
    public TreeNode copy() {
        return new let(lineNumber, copy_AbstractSymbol(identifier), copy_AbstractSymbol(type_decl), (Expression)init.copy(), (Expression)body.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "let\n");
        dump_AbstractSymbol(out, n+2, identifier);
        dump_AbstractSymbol(out, n+2, type_decl);
        init.dump(out, n+2);
        body.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_let");
	dump_AbstractSymbol(out, n + 2, identifier);
	dump_AbstractSymbol(out, n + 2, type_decl);
	init.dump_with_types(out, n + 2);
	body.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'plus'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class plus extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "plus" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public plus(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new plus(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "plus\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_plus");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'sub'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class sub extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "sub" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public sub(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new sub(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "sub\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_sub");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'mul'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class mul extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "mul" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public mul(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new mul(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "mul\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_mul");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'divide'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class divide extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "divide" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public divide(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new divide(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "divide\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_divide");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'neg'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class neg extends Expression {
    public Expression e1;
    /** Creates "neg" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      */
    public neg(int lineNumber, Expression a1) {
        super(lineNumber);
        e1 = a1;
    }
    public TreeNode copy() {
        return new neg(lineNumber, (Expression)e1.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "neg\n");
        e1.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_neg");
	e1.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'lt'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class lt extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "lt" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public lt(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new lt(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "lt\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_lt");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'eq'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class eq extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "eq" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public eq(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new eq(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "eq\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_eq");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'leq'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class leq extends Expression {
    public Expression e1;
    public Expression e2;
    /** Creates "leq" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      * @@param a1 initial value for e2
      */
    public leq(int lineNumber, Expression a1, Expression a2) {
        super(lineNumber);
        e1 = a1;
        e2 = a2;
    }
    public TreeNode copy() {
        return new leq(lineNumber, (Expression)e1.copy(), (Expression)e2.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "leq\n");
        e1.dump(out, n+2);
        e2.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_leq");
	e1.dump_with_types(out, n + 2);
	e2.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'comp'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class comp extends Expression {
    public Expression e1;
    /** Creates "comp" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      */
    public comp(int lineNumber, Expression a1) {
        super(lineNumber);
        e1 = a1;
    }
    public TreeNode copy() {
        return new comp(lineNumber, (Expression)e1.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "comp\n");
        e1.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_comp");
	e1.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'int_const'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class int_const extends Expression {
    public AbstractSymbol token;
    /** Creates "int_const" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for token
      */
    public int_const(int lineNumber, AbstractSymbol a1) {
        super(lineNumber);
        token = a1;
    }
    public TreeNode copy() {
        return new int_const(lineNumber, copy_AbstractSymbol(token));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "int_const\n");
        dump_AbstractSymbol(out, n+2, token);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_int");
	dump_AbstractSymbol(out, n + 2, token);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method method is provided
      * to you as an example of code generation.
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
	CgenSupport.emitLoadInt(CgenSupport.ACC,
                                (IntSymbol)AbstractTable.inttable.lookup(token.getString()), s);
    }

}


/** Defines AST constructor 'bool_const'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class bool_const extends Expression {
    public Boolean val;
    /** Creates "bool_const" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for val
      */
    public bool_const(int lineNumber, Boolean a1) {
        super(lineNumber);
        val = a1;
    }
    public TreeNode copy() {
        return new bool_const(lineNumber, copy_Boolean(val));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "bool_const\n");
        dump_Boolean(out, n+2, val);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_bool");
	dump_Boolean(out, n + 2, val);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method method is provided
      * to you as an example of code generation.
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
	CgenSupport.emitLoadBool(CgenSupport.ACC, new BoolConst(val), s);
    }

}


/** Defines AST constructor 'string_const'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class string_const extends Expression {
    public AbstractSymbol token;
    /** Creates "string_const" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for token
      */
    public string_const(int lineNumber, AbstractSymbol a1) {
        super(lineNumber);
        token = a1;
    }
    public TreeNode copy() {
        return new string_const(lineNumber, copy_AbstractSymbol(token));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "string_const\n");
        dump_AbstractSymbol(out, n+2, token);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_string");
	out.print(Utilities.pad(n + 2) + "\"");
	Utilities.printEscapedString(out, token.getString());
	out.println("\"");
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method method is provided
      * to you as an example of code generation.
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
	CgenSupport.emitLoadString(CgenSupport.ACC,
                                   (StringSymbol)AbstractTable.stringtable.lookup(token.getString()), s);
    }

}


/** Defines AST constructor 'new_'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class new_ extends Expression {
    public AbstractSymbol type_name;
    /** Creates "new_" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for type_name
      */
    public new_(int lineNumber, AbstractSymbol a1) {
        super(lineNumber);
        type_name = a1;
    }
    public TreeNode copy() {
        return new new_(lineNumber, copy_AbstractSymbol(type_name));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "new_\n");
        dump_AbstractSymbol(out, n+2, type_name);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_new");
	dump_AbstractSymbol(out, n + 2, type_name);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'isvoid'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class isvoid extends Expression {
    public Expression e1;
    /** Creates "isvoid" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for e1
      */
    public isvoid(int lineNumber, Expression a1) {
        super(lineNumber);
        e1 = a1;
    }
    public TreeNode copy() {
        return new isvoid(lineNumber, (Expression)e1.copy());
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "isvoid\n");
        e1.dump(out, n+2);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_isvoid");
	e1.dump_with_types(out, n + 2);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'no_expr'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class no_expr extends Expression {
    /** Creates "no_expr" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      */
    public no_expr(int lineNumber) {
        super(lineNumber);
    }
    public TreeNode copy() {
        return new no_expr(lineNumber);
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "no_expr\n");
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_no_expr");
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }


}


/** Defines AST constructor 'object'.
    <p>
    See <a href="TreeNode.html">TreeNode</a> for full documentation. */
class object extends Expression {
    public AbstractSymbol name;
    /** Creates "object" AST node. 
      *
      * @@param lineNumber the line in the source file from which this node came.
      * @@param a0 initial value for name
      */
    public object(int lineNumber, AbstractSymbol a1) {
        super(lineNumber);
        name = a1;
    }
    public TreeNode copy() {
        return new object(lineNumber, copy_AbstractSymbol(name));
    }
    public void dump(PrintStream out, int n) {
        out.print(Utilities.pad(n) + "object\n");
        dump_AbstractSymbol(out, n+2, name);
    }

    
    public void dump_with_types(PrintStream out, int n) {
        dump_line(out, n);
        out.println(Utilities.pad(n) + "_object");
	dump_AbstractSymbol(out, n + 2, name);
	dump_type(out, n);
    }
    /** Generates code for this expression.  This method is to be completed 
      * in programming assignment 5.  (You may add or remove parameters as
      * you wish.)
      * @@param s the output stream 
      * */
    public void code(PrintStream s) {
    }
d2514 6
d2521 10
d2533 20
d2554 42
@
